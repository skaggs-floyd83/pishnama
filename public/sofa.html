<!doctype html>
<!--
  Project: Pishnama â€” Sofa Fabric Assignment (Developer-Commented Copy)
  File: sofa_commented_dev.html
  Purpose:
    Two-stage flow to upload a sofa image and assign up to THREE fabrics to specific parts
    of the sofa (back/seat/arms). Uses pure HTML/CSS/vanilla JS. No network calls here.

  Key UX decisions (preserve behavior exactly):
    â€¢ Hamburger is icon-only (â˜°). Menu contains links to sofa & pillows pages.
    â€¢ File selection buttons are icon-only (ğŸ“ for choose file, ğŸ“· for camera).
    â€¢ Stages:
        1) Upload: user selects base sofa image; "Continue" becomes enabled after image loads.
        2) Fabrics: user iterates through per-fabric context and assigns fabric to parts.
    â€¢ Up to 3 fabrics are supported. The "Add Fabric" button:
        â€“ Shows â€œâ• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ {Ø¯ÙˆÙ…|Ø³ÙˆÙ…}â€ (dynamic ordinal)
        â€“ Is completely HIDDEN when three fabrics already exist (NOT disabled).
    â€¢ Placeholder text â€œÙ¾Ø§Ø±Ú†Ù‡ {Ø§ÙˆÙ„|Ø¯ÙˆÙ…|Ø³ÙˆÙ…} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯â€ appears inside the preview
      until the current fabric image is set.
    â€¢ â€œØ¨Ø®Ø´ Ù…Ø±Ø¨ÙˆØ·Ù‡â€ (part grid) controls assignment; a fabric can own any subset of parts.
      Visibility rules prevent conflicting assignments across fabrics.
    â€¢ â€œNextâ€ is always rendered (visible) but disabled when there is no next fabric.
    â€¢ â€œPreviewâ€ enables only when at least one part is selected for the current fabric.
  Notes for future devs:
    â€¢ Blob URLs (createObjectURL) are used for local previews; revoke on <img> load where applicable.
    â€¢ This page is self-contained UI only; model integration should be added where Preview is handled.
-->
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Ù¾ÛŒØ´Ù†Ù…Ø§ â€” Ù…Ø¨Ù„ (v3, commented)</title>
<style>
  /* =========================
   Theme variables
   Default = dark
  ========================= */
  :root{
    --bg:#0b1020;
    --card:#0f162b;
    --muted:#94a3b8;
    --text:#e5e7eb;
    --border:#243045;
    --accent:#22c55e;
    --blue:#1f3a8a;
  }

  /* =========================
    Light mode overrides
  ========================= */
  html[data-theme="light"]{
    --bg:#f8fafc;
    --card:#ffffff;
    --muted:#475569;
    --text:#0f172a;
    --border:#e2e8f0;
    --accent:#16a34a;
    --blue:#2563eb;
  }

  html,body{margin:0;background:var(--bg);color:var(--text);font-family:Vazirmatn,IRANSans,Segoe UI,Roboto,Arial}
  .wrap{max-width:480px;margin:0 auto;min-height:100svh;/* replaced */ height:auto;/* added */display:flex;flex-direction:column}
  .bar{position:relative;padding:10px 14px;display:flex;justify-content:flex-start;align-items:center}
  /* Icon-only hamburger; text "Ù…Ù†Ùˆ" intentionally removed */
  .hamburger{border:1px solid var(--border);background:#0f1a33;color:#e2e8f0;border-radius:10px;padding:8px 12px;cursor:pointer}
  .menu{position:absolute;top:48px;right:14px;background:var(--card);border:1px solid var(--border);border-radius:12px;min-width:180px;display:none;flex-direction:column;overflow:hidden;z-index:10}
  .menu a{padding:10px 12px;color:#e5e7eb;text-decoration:none;border-bottom:1px solid var(--border);display:block}
  .menu a:last-child{border-bottom:0}
  .menu.show{display:flex}

  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;margin:10px}
  .row{display:flex;align-items:center;gap:8px}
  .btn{border:1px solid var(--border);background:#0f1a33;color:#e2e8f0;border-radius:12px;padding:10px 14px;cursor:pointer}
  .btn.primary{background:var(--blue);border-color:var(--blue)}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  /* Generic image frame for previews/placeholders */
  .thumb{position:relative;display:flex;align-items:center;justify-content:center;border:1px solid var(--border);border-radius:12px;min-height:120px;background:#0f172a;overflow:hidden}
  .thumb img{max-width:100%;max-height:100%;width:auto;height:auto;display:block}
  .badge{position:absolute;top:8px;right:8px;background:#0f1a33;border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:.85rem;color:#e5e7eb}

  /* Quality toggle (two-state) */
  .toggle{display:inline-flex;border:1px solid var(--border);border-radius:999px;overflow:hidden}
  .toggle button{border:0;background:transparent;color:#cbd5e1;padding:8px 12px}
  .toggle .active{background:#193a88;color:#fff}

  /* Part grid â€œØ¨Ø®Ø´ Ù…Ø±Ø¨ÙˆØ·Ù‡â€: back/seat/arms/all */
  .schem{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-top:6px;align-items: center;}
  .part{height:54px;border:1px solid var(--border);border-radius:10px;background:#0f1a33;display:grid;place-items:center}
  .part.active{background:#0e3a2b;border-color:#0e3a2b}
  /* Keep a visible border when the All Parts tag is selected */
  .part[data-part="all"].active {
    border-color: var(--border);   /* same color as unselected state */
    border-width: 6px;             /* keep your thick border */
  }
  /* Make "All Parts" slightly wider with a thick border */
  .part[data-part="all"] {
    height: 68px;        /* instead of the default 54px */
    padding-inline: 44px;   /* makes it visually wider */
    border-width: 6px;      /* very thick border */
  }

  .viewport{flex:1;display:flex;flex-direction:column;gap:10px;overflow:auto/*replaced*/}
  .section{display:none;flex:1;overflow:auto/*replaced*/}
  .section.active{display:flex;flex-direction:column}

  .controls{margin:0 10px;display:flex;flex-direction:column;gap:10px;flex:1}
  .rightline{display:flex;justify-content:flex-start;align-items:center}
  .between{display:flex;justify-content:space-between;align-items:center}

  /* Fabric selection frame borrowed from pillows layout */
  .selectFrame{border:1px solid var(--border);border-radius:12px;padding:10px;background:#0f172a;display:flex;flex-direction:column;gap:10px;position:relative}

  /* Fixed heights used in mobile-safe viewport */
  #sofaThumb, #baseFrame { height: 220px !important; width: 100%; }
  #navRow{margin:0 10px;display:flex;justify-content:space-between;align-items:center}
  .tagsHeader{margin-top:14px;margin-bottom:6px;font-size:.95rem;color:var(--muted);}

  /* Tiny remove icon inside fabric frame */
  .tinyX{position:absolute;left:8px;top:8px;background:#0f1a33;border:1px solid var(--border);border-radius:8px;padding:4px 6px;cursor:pointer;font-size:14px;line-height:1}
  .tinyX:hover{background:#17213d}
  /* Toast */
  #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0f1a33;border:1px solid var(--border);color:#e5e7eb;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .25s;pointer-events:none;z-index:9999}
  #toast.show{opacity:1}

  /*  */
  /* =========================
    Base Images Album Modal
  ========================= */
  #baseAlbumModal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,.6);
    z-index: 10050;
    display: none;              /* hidden by default */
    align-items: center;
    justify-content: center;
    padding: 20px;
  }

  #baseAlbumCard {
    width: min(900px, 92vw);
    max-height: 85vh;
    overflow: auto;
    background: #0f1629;
    border: 1px solid #3a4367;
    border-radius: 12px;
    padding: 16px;
  }

  #baseAlbumGrid {
    margin-top: 16px;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
    gap: 12px;
  }

  .baseAlbumThumb {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    border-radius: 10px;
    border: 1px solid #3a4367;
    cursor: pointer;
    display: block;
    background: #0f172a;
  }
  

</style>
</head>
<body>
<div class="wrap">
  <!-- Header: hamburger only -->
  <div class="bar">
    <button class="hamburger" id="hambtn">â˜°</button>
    <button class="btn" id="loginBtn" style="margin-right:10px; direction: ltr;">ÙˆØ±ÙˆØ¯</button>
    <span id="credit-info" style="margin-right:10px;font-size:14px;"></span>
    <button class="btn" id="buyCreditsBtn" style="margin-right:10px; display:none;">
      ğŸ’³ Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±
    </button>
    <button class="btn" id="historyBtn" style="margin-right:10px; display:none;">
      ğŸ•˜ ØªØ§Ø±ÛŒØ®Ú†Ù‡
    </button>





    <div id="userMenu" 
     style="position:absolute; top:50px; right:10px; 
            background:#0f1629; border:1px solid #3a4367; 
            padding:10px; border-radius:8px; width:140px; 
            display:none; z-index:9999;">

      <button id="logoutBtn" 
              class="btn" 
              style="width:100%; background:#3a4367;">
          Ø®Ø±ÙˆØ¬
      </button>
    </div>

    <div class="menu" id="menu">
      <a href="sofa">ğŸ›‹ï¸ Ø·Ø±Ø§Ø­ÛŒ Ù…Ø¨Ù„</a>
      <a href="pillows">ğŸ›‹ï¸ Ø·Ø±Ø§Ø­ÛŒ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</a>
      <button
        id="themeToggleBtn"
        style="
          background:transparent;
          border:0;
          color:inherit;
          padding:10px 12px;
          text-align:right;
          cursor:pointer;
          font-family:inherit;
        ">
        ğŸŒ— ØªØºÛŒÛŒØ± Ø­Ø§Ù„Øª Ù†Ù…Ø§ÛŒØ´
      </button>
    </div>
  </div>

  <div class="viewport">
    <!-- ===== Stage 1: Upload base sofa image ===== -->
    <section id="step-upload" class="section active">
      <div class="card">
        <h3 style="margin:0 0 8px">ğŸ“· Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ± Ù…Ø¨Ù„</h3>
        <div class="thumb" id="sofaThumb">
          <!-- <span class="hint">Ù‡Ù†ÙˆØ² ØªØµÙˆÛŒØ±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡</span> -->
        </div>

        <div class="controls" style="margin-top: 8px;margin-right: 0px;margin-left: 0px;">
        <div class="row between">
          <!-- Icon-only file/camera per product decision -->
          <div class="row">
            <label class="btn" title="Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„">ğŸ“<input id="sofaFile" type="file" accept="image/*" hidden></label>
            <label class="btn" title="Ø¯ÙˆØ±Ø¨ÛŒÙ†">ğŸ“·<input id="sofaCam" type="file" accept="image/*" capture="environment" hidden></label>
            <label class="btn" title="Ø§Ù†ØªØ®Ø§Ø¨ Ø§Ø² Ø¢Ù„Ø¨ÙˆÙ… Ù¾Ø§ÛŒÙ‡â€ŒÙ‡Ø§" id="openBaseAlbumBtn">ğŸ“š</label>
          </div>


          <!-- Continue becomes enabled only after the image loads -->
          <button class="btn primary" id="toFabricsBtn" disabled>Ø§Ø¯Ø§Ù…Ù‡ â—€</button>
        </div>
      </div>

      </div>

    </section>

    <!-- ===== Stage 2: Fabric selection + part assignment ===== -->
    <section id="step-fabrics" class="section">
      <!-- Navigation row: â€œPrevâ€ always goes back to stage 1 if idx==0; â€œNextâ€ is visible but disabled if no next -->
      <div class="row" id="navRow">
        <button class="btn" id="prevStep">Ù‚Ø¨Ù„ÛŒ â–¶</button>
        <button class="btn" id="nextBtn">â—€ Ø¨Ø¹Ø¯ÛŒ</button>
      </div>

      <div class="card" id="frame">
        <!-- Stage 2 base sofa frame mirrors pillows layout -->
        <div class="thumb" id="baseFrame" style="margin-bottom: 15px;">
          <img id="baseImg2" alt="">
        </div>

        <!-- Fabric selection frame with thumbnail + controls -->
        <div class="selectFrame">
          <button class="tinyX" id="removeFabBtn" title="Ø­Ø°Ù Ù¾Ø§Ø±Ú†Ù‡">ğŸ—‘ï¸</button>
          <!-- I commented this line and the related codes - I will probably delete it in the future (search wizBadge to find related codes) -->
          <!-- <span class="badge" id="wizBadge" style="display: none;">Ù¾Ø§Ø±Ú†Ù‡ 1 Ø§Ø² 1</span> -->
          <div class="row" style="justify-content:flex-start;width:100%">
            <strong id="selTitle" style="color:var(--muted);font-size:.95rem;">Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø§Ø±Ú†Ù‡ Ø§ÙˆÙ„</strong>
          </div>
          <div class="row" style="justify-content:space-between;width:100%">
            <div class="rightline" style="gap:8px">
              <label class="btn" title="Ø¢Ù¾Ù„ÙˆØ¯ Ù¾Ø§Ø±Ú†Ù‡">ğŸ“<input id="fabFile" type="file" accept="image/*" hidden></label>
              <label class="btn" title="Ø¯ÙˆØ±Ø¨ÛŒÙ†">ğŸ“·<input id="fabCam" type="file" accept="image/*" capture="environment" hidden></label>
              <label class="btn" title="Ø§Ù†ØªØ®Ø§Ø¨ Ø§Ø² Ø¢Ù„Ø¨ÙˆÙ… Ù¾Ø§Ø±Ú†Ù‡â€ŒÙ‡Ø§" id="openFabricAlbumBtn">ğŸ“š</label>
            </div>

            <img id="fabImg" alt="" style="width:36px;height:36px;border-radius:8px;border:1px solid var(--border);object-fit:cover;background:#0f172a;visibility:hidden">
          </div>
          <!-- I commented this line and the related codes - I will probably delete it in the future (search fabPlaceholder to find related codes) -->
          <!-- <span id="fabPlaceholder" style="color:var(--muted);font-size:.9rem;display:block;">Ù¾Ø§Ø±Ú†Ù‡ Ø§ÙˆÙ„ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</span> -->
          <div>
            <div class="tagsHeader" style="margin-top:0">Ø¨Ø®Ø´ Ù…Ø±Ø¨ÙˆØ· Ø¨Ù‡ Ø§ÛŒÙ† Ù¾Ø§Ø±Ú†Ù‡</div>
            <div class="schem" id="schem">
              <button class="part" data-part="all" style="color: #e2e8f0;">Ù‡Ù…Ù‡</button>
              <button class="part" data-part="back" style="color: #e2e8f0;">Ù¾Ø´ØªÛŒ</button>
              <button class="part" data-part="seat" style="color: #e2e8f0;">Ù†Ø´ÛŒÙ…Ù†</button>
              <button class="part" data-part="arms" style="color: #e2e8f0;">Ø¯Ø³ØªÙ‡â€ŒÙ‡Ø§</button>
              
            </div>
          </div>
        </div>

        <!-- Add Fabric: HIDDEN when fabrics.length >= 3; otherwise enabled based on selection readiness -->
        <div class="controls">
          <div class="rightline" style="margin-top: 10px;">
            <button class="btn" id="addBtn">â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ Ø¯ÙˆÙ…</button>
          </div>
        </div>

      </div>



      <!-- Generate row: quality toggle + preview (integration point for the model) -->
      <div class="controls">
        <div class="rightline" style="gap:8px; margin-bottom: 20px; margin-top: 10px;">
          <div class="toggle" id="qToggle" style="margin-left: 10px;">
            <button class="active" data-q="high">Ù‡ÙˆØ´ ÛŒÚ© &nbsp; (2 Ø³Ú©Ù‡)</button>
            <button data-q="standard">Ù‡ÙˆØ´ Ø¯Ùˆ &nbsp; (1 Ø³Ú©Ù‡)</button>
          </div>
          <button class="btn primary" id="previewBtn">âœ¨ Ø¨Ø³Ø§Ø²</button>
        </div>
      </div>
    </section>

    <!-- ===== Stage 3: Output ===== -->
    <section id="step-output" class="section">
      <div class="card">
        <h3 style="margin:0 0 10px">âœ… Ù†ØªÛŒØ¬Ù‡ Ù†Ù‡Ø§ÛŒÛŒ</h3>

        <div class="thumb" style="margin-bottom:12px">
          <img id="outputImg" alt="">
        </div>

        <div class="row between">
          <button class="btn" id="backToEditBtn">âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´</button>
          <button class="btn primary" id="shareBtn">ğŸ”— Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ</button>
        </div>
      </div>
    </section>

  </div>
</div>
<div id="restoreOverlay"
     style="
       position:fixed;
       inset:0;
       background:rgba(0,0,0,0.55);
       display:none;
       align-items:center;
       justify-content:center;
       z-index:100000;
       color:#fff;
       font-size:16px;
     ">
  â³ Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒâ€¦
</div>

<script>
/* =============================================================================
   Pishnama â€” Sofa Page (Inline Script, Refactored)
   Scope: Internal modularization & comments ONLY â€” ZERO behavior/UI changes
   Notes:
     - Public IDs/classes and Persian text are untouched.
     - Structure: Typedefs â†’ Constants/DOM â†’ State â†’ Helpers â†’ Core UI Sync
                  â†’ Validation/Export â†’ Handlers â†’ Event Bindings â†’ Init
============================================================================= */

/** ============================================================================
 * Typedefs (documentation only)
 * @typedef {{ id:number, url:string, file?:File, parts:Set<'back'|'seat'|'arms'> }} Fabric
 * @typedef {{ back:number|null, seat:number|null, arms:number|null }} Assigned
 * ========================================================================== */

/* ============================== Constants / DOM ============================ */

function displayPhone(identifier) {
    // Convert +989123456789 â†’ 09123456789
    if (identifier.startsWith("+98") && identifier.length === 13) {
        return "0" + identifier.slice(3);
    }
    return identifier; // email or unexpected case
}

function updateLoginButton() {

    // Hard reset auth-dependent UI
    document.getElementById("credit-info").textContent = "";
    
    const buyCreditsBtn = document.getElementById("buyCreditsBtn");
    const historyBtn = document.getElementById("historyBtn");
    const userMenu = document.getElementById("userMenu");
    const creditInfo = document.getElementById("credit-info");

    if (buyCreditsBtn) buyCreditsBtn.style.display = "none";
    if (historyBtn) historyBtn.style.display = "none";
    if (userMenu) userMenu.style.display = "none";
    if (creditInfo) creditInfo.textContent = "";
    // NEW: hide credit-info completely when logged out (expiry is inside this text)
    if (creditInfo) creditInfo.style.display = "none";




    const btn = document.getElementById("loginBtn");
    if (!btn) return;

    const token = localStorage.getItem("pishnama_user_token");
    const identifier = localStorage.getItem("pishnama_user_identifier");
    
    
    if (token) {
      if (creditInfo) creditInfo.style.display = "inline";
      if (buyCreditsBtn) buyCreditsBtn.style.display = "inline-block";
      if (historyBtn) historyBtn.style.display = "inline-block";
    } else {
      if (creditInfo) { creditInfo.textContent = ""; creditInfo.style.display = "none"; }
      if (buyCreditsBtn) buyCreditsBtn.style.display = "none";
      if (historyBtn) historyBtn.style.display = "none";
    }



    if (token) {
        // User is logged in
        btn.textContent = displayPhone(identifier);
        btn.disabled = false;      // optional: prevent modal opening
        btn.style.opacity = "0.8";
    } else {
        // User is not logged in
        btn.textContent = "ÙˆØ±ÙˆØ¯";
        btn.disabled = false;
        btn.style.opacity = "1";
        userMenu.style.display = "none";
    }


    if (!token && creditInfo) {
        creditInfo.textContent = "";
    }


}

function forceLogoutIfInvalid(tokenResponse, authOptions = {}) {
    if (tokenResponse && tokenResponse.error === "login_required") {
        // Clear credentials
        localStorage.removeItem("pishnama_user_token");
        localStorage.removeItem("pishnama_user_identifier");
        void clearImageCache();

        // If this is an automatic logout (page load / background fetch),
        // do a hard refresh to guarantee a clean UI state.
        if (authOptions.silent) {
            window.location.reload();
            return true;
        }

        // User-visible logout (no refresh)
        updateLoginButton();
        showToast("Ù†Ø´Ø³Øª Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.");
        return true;
    }
    return false;
}






async function fetchWithAuth(url, options = {}) {
  const token = localStorage.getItem("pishnama_user_token");

  const res = await fetch(url, {
    ...options,
    headers: {
      ...(options.headers || {}),
      "x-user-token": token || ""
    }
  });

  let data = null;
  try {
    data = await res.json();
  } catch (_) {}

  // Centralized auth invalidation
  if (res.status === 401 || data?.error === "login_required") {
    forceLogoutIfInvalid(data, options?.auth || {});
    throw new Error("Unauthorized");
  }

  return { res, data };
}

const IMAGE_CACHE_DB = "pishnama_image_cache";
const IMAGE_CACHE_VERSION = 1;
const THUMB_STORE = "thumbs";
const FULL_STORE = "full";

function openImageCache() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(IMAGE_CACHE_DB, IMAGE_CACHE_VERSION);

    request.onupgradeneeded = () => {
      const db = request.result;
      if (!db.objectStoreNames.contains(THUMB_STORE)) {
        db.createObjectStore(THUMB_STORE, { keyPath: "key" });
      }
      if (!db.objectStoreNames.contains(FULL_STORE)) {
        db.createObjectStore(FULL_STORE, { keyPath: "key" });
      }
    };

    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
}

async function getCachedBlob(storeName, key) {
  const db = await openImageCache();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readonly");
    const store = tx.objectStore(storeName);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result?.blob || null);
    req.onerror = () => reject(req.error);
  });
}

async function setCachedBlob(storeName, key, blob) {
  const db = await openImageCache();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(storeName, "readwrite");
    const store = tx.objectStore(storeName);
    store.put({ key, blob, updatedAt: Date.now() });
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function clearImageCache() {
  const db = await openImageCache();
  return new Promise((resolve, reject) => {
    const tx = db.transaction([THUMB_STORE, FULL_STORE], "readwrite");
    tx.objectStore(THUMB_STORE).clear();
    tx.objectStore(FULL_STORE).clear();
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function fetchImageBlobWithAuth(url) {
  const token = localStorage.getItem("pishnama_user_token");
  const res = await fetch(url, {
    headers: {
      "x-user-token": token || ""
    }
  });
  if (!res.ok) return null;
  return await res.blob();
}

async function setImageFromCacheOrFetch(img, url, storeName) {
  if (!img || !url) return;
  const cached = await getCachedBlob(storeName, url);
  if (cached) {
    const objectUrl = URL.createObjectURL(cached);
    img.src = objectUrl;
    img.onload = () => URL.revokeObjectURL(objectUrl);
    return;
  }

  const blob = await fetchImageBlobWithAuth(url);
  if (!blob) {
    img.src = url;
    return;
  }
  await setCachedBlob(storeName, url, blob);
  const objectUrl = URL.createObjectURL(blob);
  img.src = objectUrl;
  img.onload = () => URL.revokeObjectURL(objectUrl);
}

function loadBlobToImage(blob) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = (err) => {
      URL.revokeObjectURL(url);
      reject(err);
    };
    img.src = url;
  });
}

async function createThumbnailBlob(blob) {
  const img = await loadBlobToImage(blob);
  const maxSide = 320;
  const scale = Math.min(1, maxSide / Math.max(img.width || 1, img.height || 1));
  const targetW = Math.max(1, Math.round((img.width || maxSide) * scale));
  const targetH = Math.max(1, Math.round((img.height || maxSide) * scale));

  const canvas = document.createElement("canvas");
  canvas.width = targetW;
  canvas.height = targetH;
  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, targetW, targetH);

  return new Promise(resolve => {
    canvas.toBlob(
      blobOut => resolve(blobOut),
      "image/jpeg",
      0.75
    );
  });
}

async function setHistoryThumb(img, item) {
  if (!img) return;
  if (item.output_thumb_url) {
    await setImageFromCacheOrFetch(img, item.output_thumb_url, THUMB_STORE);
    return;
  }

  if (!item.output_image_url) return;

  const cached = await getCachedBlob(THUMB_STORE, item.output_image_url);
  if (cached) {
    const objectUrl = URL.createObjectURL(cached);
    img.src = objectUrl;
    img.onload = () => URL.revokeObjectURL(objectUrl);
    return;
  }

  const fullBlob = await fetchImageBlobWithAuth(item.output_image_url);
  if (!fullBlob) {
    img.src = item.output_image_url;
    return;
  }

  const thumbBlob = await createThumbnailBlob(fullBlob);
  if (thumbBlob) {
    await setCachedBlob(THUMB_STORE, item.output_image_url, thumbBlob);
    const objectUrl = URL.createObjectURL(thumbBlob);
    img.src = objectUrl;
    img.onload = () => URL.revokeObjectURL(objectUrl);
    return;
  }

  img.src = item.output_image_url;
}




// Maps 1..3 to Persian ordinals: Ø§ÙˆÙ„ / Ø¯ÙˆÙ… / Ø³ÙˆÙ…
function faOrdinal(n){ return n===1?'Ø§ÙˆÙ„':(n===2?'Ø¯ÙˆÙ…':'Ø³ÙˆÙ…'); }

// Hamburger
const hambtn   = document.getElementById('hambtn');
const menu     = document.getElementById('menu');

// Stage 1 (Upload)
const sofaFile     = document.getElementById('sofaFile');
const sofaCam      = document.getElementById('sofaCam');
const sofaThumb    = document.getElementById('sofaThumb');
const toFabricsBtn = document.getElementById('toFabricsBtn');
const stepUpload   = document.getElementById('step-upload');

// Stage 2 (Fabrics)
const stepFabrics  = document.getElementById('step-fabrics');
const baseImg2     = document.getElementById('baseImg2');
const fabFile      = document.getElementById('fabFile');
const fabCam       = document.getElementById('fabCam');
const fabImg       = document.getElementById('fabImg');
const selTitle     = document.getElementById('selTitle');
// const wizBadge     = document.getElementById('wizBadge');
const qToggle      = document.getElementById('qToggle');
const schem        = document.getElementById('schem');
const previewBtn   = document.getElementById('previewBtn');
const addBtn       = document.getElementById('addBtn');
const nextBtn      = document.getElementById('nextBtn');
const prevStep     = document.getElementById('prevStep');

// Logical part names; used for visibility rules and assignments
const parts = ['back','seat','arms'];

/* ================================== State ================================= */

// Global UI state (no persistence)
let sofaChosen   = false; // becomes true after an image is picked
/** @type {Fabric[]} */
let fabrics      = [];    // each item: { id, url, parts:Set<string> }
 /** @type {Assigned} */
let assigned     = {back:null, seat:null, arms:null}; // which fabric id owns each part (or null)
let idx          = 0;     // index of "current" fabric being edited
let sofaBaseFile = null;  // keep original base sofa File for export

// NEW: Global quality setting (standard | high)
let generationQuality = "high";

let historyPage = 1;
let historyTotal = 0;
const HISTORY_PAGE_SIZE = 20;


/* =============================== Helpers ================================== */

async function refreshCredits() {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) return;

  
  let data;
  try {
    ({ data } = await fetchWithAuth("/api/credits", {
      auth: { silent: true }
    }));
  } catch {
    return;
  }


  const el = document.getElementById("credit-info");
  if (!el) return;

  if (data.credits_expires_at) {
    el.textContent = `Ø§Ø¹ØªØ¨Ø§Ø±: ${data.credits} (ØªØ§ ${new Date(data.credits_expires_at).toLocaleDateString("fa-IR")})`;
  } else {
    el.textContent = `Ø§Ø¹ØªØ¨Ø§Ø±: ${data.credits}`;
  }
  el.style.display = "inline";
}


/** Set <img>.src with a Blob URL; revoke URL after load to avoid leaks */
function loadImage(el, file){
  const url = URL.createObjectURL(file);
  el.src = url;
  el.onload = () => URL.revokeObjectURL(url);
}

function waitForImage(img) {
  return new Promise(resolve => {
    if (!img) return resolve();
    if (img.complete && img.naturalWidth > 0) return resolve();
    img.onload = () => resolve();
    img.onerror = () => resolve();
  });
}



// Fetch & render history
async function loadHistory(reset = false) {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) return;

  if (reset) {
    historyPage = 1;
    document.getElementById("historyGrid").innerHTML = "";
  }

  let data;
  try {
    ({ data } = await fetchWithAuth(
      `/api/history?page=${historyPage}&pageSize=${HISTORY_PAGE_SIZE}`
    ));
  } catch {
    return;
  }



  historyTotal = data.total;

  for (const item of data.items) {
    const div = document.createElement("div");
    div.style.border = "1px solid #3a4367";
    div.style.borderRadius = "8px";
    div.style.padding = "6px";
    div.style.fontSize = "12px";

    div.innerHTML = `
      <img
        data-creation-id="${item.id}"
        class="history-thumb"
        style="width:100%; border-radius:6px; display:block; cursor:pointer;">
      <div style="margin-top:6px;">
        <div>Ù†ÙˆØ¹: ${item.mode}</div>
        <div>Ú©ÛŒÙÛŒØª: ${item.quality}</div>
        <div>Ù‡Ø²ÛŒÙ†Ù‡: ${item.cost_credits}</div>
        <div>${new Date(item.created_at).toLocaleDateString("fa-IR")}</div>
      </div>
    `;

    document.getElementById("historyGrid").appendChild(div);
    const img = div.querySelector(".history-thumb");
    void setHistoryThumb(img, item);
  }

  historyPage++;

  const shown = document.getElementById("historyGrid").children.length;
  document.getElementById("historyLoadMoreBtn").style.display =
    shown < historyTotal ? "inline-block" : "none";
}







// ======================= IMAGE COMPRESSION HELPERS =========================

const MAX_BASE_BYTES   = 3 * 1024 * 1024;  // 3 MB threshold for sofa base image
const MAX_FABRIC_BYTES = 3 * 1024 * 1024;  // 3 MB threshold for fabrics
const BASE_MAX_SIDE    = 1536;             // max width/height for sofa image
const FABRIC_MAX_SIDE  = 1024;             // max width/height for fabrics

function ensureJpegName(name) {
  if (!name) return "image.jpg";
  return name.replace(/\.[^.]+$/,"") + ".jpg";
}

/**
 * Load a File into an HTMLImageElement using a Blob URL.
 */
function loadFileToImage(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = (err) => {
      URL.revokeObjectURL(url);
      reject(err);
    };
    img.src = url;
  });
}

/**
 * Compress & normalize an image *if needed*:
 *  - If JPEG and under maxBytes â†’ returned as-is
 *  - Otherwise â†’ resized to maxSide (inside) and encoded as JPEG,
 *    trying a few quality steps until under maxBytes (or quality floor).
 */
async function compressImageIfNeeded(file, { maxBytes, maxSide }) {
  // No need to touch small JPEGs
  if (file.type === "image/jpeg" && file.size <= maxBytes) {
    return file;
  }

  const img = await loadFileToImage(file);
  const longest = Math.max(img.width || maxSide, img.height || maxSide);
  const scale   = longest > maxSide ? (maxSide / longest) : 1;

  const targetW = Math.max(1, Math.round((img.width  || maxSide) * scale));
  const targetH = Math.max(1, Math.round((img.height || maxSide) * scale));

  const canvas = document.createElement("canvas");
  canvas.width  = targetW;
  canvas.height = targetH;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, targetW, targetH);

  // Try a few qualities until we get under the threshold
  let quality = 0.85;
  let lastBlob = null;

  for (let i = 0; i < 4; i++) {
    const blob = await new Promise(resolve =>
      canvas.toBlob(resolve, "image/jpeg", quality)
    );
    if (!blob) break;
    lastBlob = blob;

    if (blob.size <= maxBytes || quality <= 0.6) {
      return new File([blob], ensureJpegName(file.name), { type: "image/jpeg" });
    }
    quality -= 0.1;
  }

  // Fallback: return best attempt if we never got under maxBytes
  if (lastBlob) {
    return new File([lastBlob], ensureJpegName(file.name), { type: "image/jpeg" });
  }
  // Ultimate fallback: original file
  return file;
}


/** Stage navigation (no side effects beyond DOM visibility) */
function gotoUpload(){
  stepFabrics.classList.remove('active');
  stepUpload.classList.add('active');

  // re-render base image when returning to stage 1 (e.g. after restore)
  if (sofaBaseFile && sofaThumb) {
    sofaThumb.innerHTML = '<img>';
    loadImage(sofaThumb.firstElementChild, sofaBaseFile);

    // allow going forward again after restore
    toFabricsBtn.disabled = false;
  }
}

function gotoFabrics(){
  stepUpload.classList.remove('active');
  stepFabrics.classList.add('active');
  updateUI();
}

const stepOutput = document.getElementById("step-output");
const outputImg = document.getElementById("outputImg");
function gotoOutput() {
  stepUpload.classList.remove("active");
  stepFabrics.classList.remove("active");
  stepOutput.classList.add("active");
}



/* ============================== Core UI Sync ============================== */
/*
  Responsibilities:
    1) Update preview image + placeholder text
    2) Update part grid visibility/active states under conflicting assignments
    3) Manage â€œAdd Fabricâ€ (show/hide + label + enabled state)
    4) Keep â€œNextâ€ visible but disabled when there is no next fabric
    5) Enable Preview (generate) â€” validation happens on click
*/
function updateUI(){
  if(!fabrics[idx]) return;
  const cur = fabrics[idx];

  // 1) Preview (image or ordinal placeholder)
  fabImg.src = cur.url || '';
  fabImg.style.visibility = cur.url ? 'visible' : 'hidden';
  // const ph = document.getElementById('fabPlaceholder');
  // if(cur.url){ ph.style.display='none'; }
  // else { ph.textContent = `Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(idx+1)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯`; ph.style.display='block'; }
  if(selTitle){ selTitle.textContent = `Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(idx+1)}`; }

  // Wizard badge: "Ù¾Ø§Ø±Ú†Ù‡ X Ø§Ø² N"
  // wizBadge.textContent = `Ù¾Ø§Ø±Ú†Ù‡ ${idx+1} Ø§Ø² ${fabrics.length}`;

  // 2) Part grid visibility & active states
  schem.querySelectorAll('.part').forEach(btn=>{
    const p = btn.dataset.part;
    if(p==='all'){
      const allAvail = parts.every(pa => (assigned[pa]===null || assigned[pa]===cur.id));
      btn.style.visibility = allAvail ? 'visible' : 'hidden';
      btn.classList.toggle('active', cur.parts.size===3);
    }else{
      const visible = (assigned[p]===null || assigned[p]===cur.id);
      btn.style.visibility = visible ? 'visible' : 'hidden';
      btn.classList.toggle('active', cur.parts.has(p));
    }
  });

  // 5) Generate is always enabled; validation happens on click now
  previewBtn.disabled = false;

  // 3) Add Fabric management
  if(fabrics.length>=3){
    addBtn.style.display='none';
  }else{
    addBtn.style.display='inline-block';
    const nextOrdinal = faOrdinal(Math.min(fabrics.length+1,3));
    addBtn.textContent = `â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ ${nextOrdinal}`;

    const allAssignedOverall = parts.every(p=>assigned[p]!==null);
    const curAll = (cur.parts.size===3);
    const currentReady = !!cur.url && cur.parts.size>0;
    addBtn.disabled = allAssignedOverall || curAll || !currentReady;
  }

  // 4) Next button: always present; disabled if there is no next fabric
  nextBtn.style.display='inline-block';
  

  // Can move to next fabric only if:
  // 1) there IS a next fabric
  // 2) current fabric has an image AND at least one sofa part selected
  let canAdvance = false;

  if (idx < fabrics.length - 1) {    
    canAdvance = !!cur.url && !!cur.parts && cur.parts.size > 0;
  }

  nextBtn.disabled = !canAdvance;





}

/* ===================== Validation (pre-generation) ======================== */

function validateBeforeGenerateSofa(){
  const errors = [];
  const warnings = [];

  // --- Mandatory checks ---
  if(!sofaChosen){
    errors.push("\n- ØªØµÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡Ù” Ù…Ø¨Ù„ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
  }
  const fabricsWithImg = fabrics.filter(f=>!!f.url);
  if(fabricsWithImg.length===0){
    errors.push("\n- Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ØªØµÙˆÛŒØ± Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ø§ÛŒØ¯ Ø¢Ù¾Ù„ÙˆØ¯ Ø´ÙˆØ¯.");
  }
  const anyTaggedOnImg = fabrics.some(f=> !!f.url && f.parts && f.parts.size>0 );
  if(!anyTaggedOnImg){
    errors.push("\n- Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø¨Ø±Ú†Ø³Ø¨ Ø¨Ø®Ø´ (Ù¾Ø´ØªÛŒ/Ù†Ø´ÛŒÙ…Ù†/Ø¯Ø³ØªÙ‡â€ŒÙ‡Ø§) Ø¨Ø§ÛŒØ¯ Ø¨Ù‡ ÛŒÚ©ÛŒ Ø§Ø² Ù¾Ø§Ø±Ú†Ù‡â€ŒÙ‡Ø§ÛŒ Ø¢Ù¾Ù„ÙˆØ¯ Ø´Ø¯Ù‡ Ø§Ø®ØªØµØ§Øµ Ø¯Ø§Ø¯Ù‡ Ø´ÙˆØ¯.");
  }

  // --- Optional checks ---
  // A) Fabric images without any assigned parts
  const imgNoTags = fabrics
    .map((f,i)=>({f,i}))
    .filter(({f})=> !!f.url && (!f.parts || f.parts.size===0))
    .map(({i})=> `Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(i+1)}`);
  if(imgNoTags.length>0){
    warnings.push("\n- Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø®ÛŒ Ù¾Ø§Ø±Ú†Ù‡â€ŒÙ‡Ø§ Ø¨Ø®Ø´ÛŒ ØªØ¹ÛŒÛŒÙ† Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª: " + imgNoTags.join("ØŒ "));
  }

  // B) Parts selected for a fabric slot that has NO image yet (tags without fabric image)
  const partsFa = {back:"Ù¾Ø´ØªÛŒ", seat:"Ù†Ø´ÛŒÙ…Ù†", arms:"Ø¯Ø³ØªÙ‡â€ŒÙ‡Ø§"};
  const tagsNoImg = fabrics
    .map((f,i)=>({f,i}))
    .filter(({f})=> !f.url && f.parts && f.parts.size>0)
    .map(({f,i})=> `${[...f.parts].map(p=>partsFa[p]).join("ØŒ ")} â‡ Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(i+1)}`);
  if(tagsNoImg.length>0){
    warnings.push("\n- Ø¨Ø®Ø´ Ù‡Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ú©Ù‡ Ù¾Ø§Ø±Ú†Ù‡â€ŒØ§ÛŒ Ø¨Ø±Ø§ÛŒØ´Ø§Ù† Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡:\n " + tagsNoImg.join(" | "));
  }

  // C) Not all sofa parts (seat, back, arms) are assigned across fabrics
  (function(){
    const required = ["back","seat","arms"];
    const seen = new Set();
    fabrics.forEach(f=>{
      if(f && f.url && f.parts && f.parts.size>0){
        [...f.parts].forEach(p=>seen.add(p));
      }
    });
    const missing = required.filter(p=>!seen.has(p));
    if(missing.length>0){
      const partsFa2 = {back:"Ù¾Ø´ØªÛŒ", seat:"Ù†Ø´ÛŒÙ…Ù†", arms:"Ø¯Ø³ØªÙ‡â€ŒÙ‡Ø§"};
      warnings.push("\n- Ø¨Ø±Ø§ÛŒ Ø¨Ø±Ø®ÛŒ Ø¨Ø®Ø´â€ŒÙ‡Ø§ÛŒ Ù…Ø¨Ù„ Ù¾Ø§Ø±Ú†Ù‡ Ø¬Ø¯ÛŒØ¯ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª: " + missing.map(m=>partsFa2[m]).join("ØŒ "));
    }
  })();

  return {errors, warnings};
}

/* ========================== Export / ZIP Helpers ========================== */

function tsNow(){
  const p = new Date();
  const z = n=>String(n).padStart(2,'0');
  return `${p.getFullYear()}-${z(p.getMonth()+1)}-${z(p.getDate())}_${z(p.getHours())}-${z(p.getMinutes())}-${z(p.getSeconds())}`;
}
function ext(name){
  const i = name.lastIndexOf('.'); return i>=0 ? name.slice(i) : '.png';
}
function downloadBlob(blob, filename){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download=filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2500);
}

/** Build meta/files overview WITHOUT side effects (pure builder) */
function buildSofaMetaAndFiles(){
  // use global quality (no longer read from DOM)
  const quality = generationQuality;


  const included = [];
  const excluded = [];
  fabrics.forEach((f,fi)=>{
    const id = `fabric_${String(fi+1).padStart(2,'0')}`;
    const hasFile = !!f.file;
    const partsList = f.parts ? Array.from(f.parts) : [];
    if(hasFile && partsList.length>0){
      included.push({ id, parts: partsList, file: f.file });
    }else{
      const reason = !hasFile ? 'no image' : 'no parts';
      excluded.push({ id, reason });
    }
  });

  // Determine mode_selection for sofa:
  // "all"  â†’ if ANY fabric covers all three parts
  // "partial" â†’ otherwise
  let modeSelectionSofa = "partial";
  for (const f of fabrics) {
    if (f.parts && f.parts.size === 3) {
      modeSelectionSofa = "all";
      break;
    }
  }

  const meta = {
    mode: 'sofa',
    mode_selection: modeSelectionSofa,   // <-- NEW
    quality,
    fabrics: included.map(x=>({id:x.id, parts:x.parts})),
    excluded,
    files: {
      base_image: sofaBaseFile ? 'base_image'+ext(sofaBaseFile.name) : null,
      fabrics: included.map(x=> x.id + ext(x.file.name))
    }
  };



  const lines = [];
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'local';
  lines.push('=== HEADER ===');
  lines.push('mode: sofa');
  lines.push(`timestamp: ${new Date().toLocaleString()} (${tz})`);
  lines.push(`quality: ${quality}`);
  lines.push('');
  lines.push('=== INCLUDED FABRICS ===');
  if(included.length===0){ lines.push('(none)'); }
  included.forEach(x=>{
    lines.push(`- ${x.id}: file="${x.id+ext(x.file.name)}"`);
    lines.push(`  sofa.parts: [${x.parts.join(', ')}]`);
  });
  lines.push('');
  lines.push('=== EXCLUSIONS (NOT SENT) ===');
  if(excluded.length===0){ lines.push('(none)'); }
  excluded.forEach(x=> lines.push(`- ${x.id}: reason=${x.reason}`));
  lines.push('');
  lines.push('=== FILES IN THIS EXPORT ===');
  if(sofaBaseFile) lines.push(`- ${'base_image'+ext(sofaBaseFile.name)}`);
  included.forEach(x=> lines.push(`- ${x.id+ext(x.file.name)}`));

  return {meta, included, metaTxt: lines.join('\n'), quality};
}

/* ========================== Toast (UI affordance) ========================= */

function showToast(msg){
  const t=document.getElementById('toast'); if(!t) return;
  t.textContent=msg; t.classList.add('show');
  setTimeout(()=>t.classList.remove('show'), 1600);
}

/* ============================ Named Handlers ============================== */

// Hamburger: toggle menu
function handleHamburgerClick(){
  menu.classList.toggle('show');
}
// Close menu on outside click
function handleDocumentClick(e){
  if(!menu.contains(e.target) && e.target!==hambtn) menu.classList.remove('show');
}

// Stage nav
function handlePrevStepClick(){
  if(idx>0){ idx--; updateUI(); } else { gotoUpload(); }
}
function handleNextBtnClick(){
  if(idx<fabrics.length-1){ idx++; updateUI(); }
}

// Add a new fabric slot (up to 3). Starts empty (no image, no parts).
function handleAddBtnClick(){
  if(addBtn.disabled) return;
  // Start fresh: clear file inputs so the next pick always fires 'change'
  try{ const _f=document.getElementById('fabFile'); if(_f) _f.value=''; }catch(e){}
  try{ const _c=document.getElementById('fabCam');  if(_c) _c.value=''; }catch(e){}
  fabrics.push({id:fabrics.length, url:'', parts:new Set()});
  idx = fabrics.length-1;
  updateUI();
}


// Stage 1: selecting the base sofa image enables Continue after load
async function handleSofaFileChange(e){
  const originalFile = e.target.files?.[0];
  if (!originalFile) return;

  // Compress / normalize if needed
  const file = await compressImageIfNeeded(originalFile, {
    maxBytes: MAX_BASE_BYTES,
    maxSide: BASE_MAX_SIDE
  });

  sofaChosen   = true;
  sofaBaseFile = file;

  toFabricsBtn.disabled = false;
  sofaThumb.innerHTML = '<img>';
  loadImage(sofaThumb.firstElementChild, file);
  if (baseImg2) {
    loadImage(baseImg2, file);
  }

  if (fabrics.length === 0) {
    fabrics.push({ id: 0, url: "", parts: new Set(["back", "seat", "arms"]) });
    assigned = { back: 0, seat: 0, arms: 0 };
  }
  idx = 0;
}


// Camera mirrors file selection
function handleSofaCamChange(){
  sofaFile.dispatchEvent(new Event('change'));
}
function handleToFabricsClick(){
  if(!sofaChosen) return;
  gotoFabrics();
}

// Fabric image selection for current fabric idx
async function setFabricFromFile(file){
  // Compress / normalize if needed
  const processed = await compressImageIfNeeded(file, {
    maxBytes: MAX_FABRIC_BYTES,
    maxSide: FABRIC_MAX_SIDE
  });

  // Revoke previous object URL (if any) to avoid leaks
  if (fabrics[idx]?.url) {
    try { URL.revokeObjectURL(fabrics[idx].url); } catch (e) {}
  }

  const url = URL.createObjectURL(processed);
  fabrics[idx].url  = url;
  fabrics[idx].file = processed;
  fabImg.src = url;

  updateUI();
}


async function handleFabFileChange(e){
  const f = e.target.files?.[0];
  if (!f) return;
  await setFabricFromFile(f);
  // Reset input so selecting the same file triggers 'change' in Chrome/Edge
  e.target.value = "";
}

async function handleFabCamChange(e){
  const f = e.target.files?.[0];
  if (!f) return;
  await setFabricFromFile(f);
  // Reset input so selecting the same capture triggers 'change' in Chrome/Edge
  e.target.value = "";
}


// Quality toggle: (high/standard) 
function handleQToggleClick(e){
  const b = e.target.closest('button');
  if(!b) return;

  // Update UI active state
  [...qToggle.children].forEach(x=>x.classList.toggle('active',x===b));

  // Update global quality state 
  generationQuality = b.dataset.q;
}


// Part assignment rules (see original comments)
function handleSchemClick(e){
  const btn=e.target.closest('.part'); if(!btn||!fabrics[idx]) return;
  const p=btn.dataset.part;
  const cur=fabrics[idx];

  if(p==='all'){
    const allAvail=parts.every(pa=>(assigned[pa]===null||assigned[pa]===cur.id));
    if(!allAvail) return;
    const turnOn=(cur.parts.size!==3);
    parts.forEach(pa=>{
      if(turnOn){ cur.parts.add(pa); assigned[pa]=cur.id; }
      else{ cur.parts.delete(pa); if(assigned[pa]===cur.id) assigned[pa]=null; }
    });
  }else{

    // If user clicks an individual part while "all" is active:
    // we must turn off "all" and activate only that specific part.
    if (cur.parts.size === 3 && p !== "all") {
      parts.forEach(pa => cur.parts.delete(pa)); // clear all
      cur.parts.add(p);                          // activate selected one
      // update assigned:
      parts.forEach(pa => { if (assigned[pa] === cur.id) assigned[pa] = null; });
      assigned[p] = cur.id;
      updateUI();
      return;
    }


    const visible=(assigned[p]===null||assigned[p]===cur.id);
    if(!visible) return;
    if(cur.parts.has(p)){ cur.parts.delete(p); if(assigned[p]===cur.id) assigned[p]=null; }
    else { cur.parts.add(p); assigned[p]=cur.id; }
  }
  updateUI();
}

// Validation + ZIP build + download
async function handlePreviewClick(){

  // ========== REQUIRE LOGIN ==========
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) {
      alert("Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ØŒ Ù„Ø·ÙØ§Ù‹ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.");
      loginModal.style.display = "flex";   // show the login modal automatically
      return;
  }

  // Compute required cost on client
  const cost = (generationQuality === "high") ? 2 : 1;
  // Call credits endpoint BEFORE validation & uploads
  let creditData;
  try {
    ({ data: creditData } = await fetchWithAuth("/api/credits"));
  } catch {
    return; // login_required already handled
  }

  if (creditData.credits < cost) {
    alert(
      `Ø§Ø¹ØªØ¨Ø§Ø± Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª.\n` +
      `Ù…ÙˆØ¬ÙˆØ¯ÛŒ: ${creditData.credits}\n` +
      `Ù†ÛŒØ§Ø²: ${cost}`
    );
    return;
  }

  const {errors, warnings} = validateBeforeGenerateSofa();
  if(errors.length>0){
    alert("Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ: " + errors.join(" "));
    return;
  }
  if(warnings.length>0){
    const proceed = confirm("Ù…ÙˆØ§Ø±Ø¯ Ø§Ø®ØªÛŒØ§Ø±ÛŒ (Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§ØµÙ„Ø§Ø­ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯): " + warnings.join(" ") + "\nØ§Ø¯Ø§Ù…Ù‡Ù” ØªÙˆÙ„ÛŒØ¯ØŸ");
    if(!proceed) return;
  }



  const {meta, included} = buildSofaMetaAndFiles();

  try {
    enterRestoreLoading();
    const imageBase64 = await sendToBackend(meta, included, sofaBaseFile);
    if (!imageBase64) return;

    outputImg.src = "data:image/png;base64," + imageBase64;
    gotoOutput();
    await waitForImage(outputImg);
    refreshCredits();



  } catch (err) {
    console.error(err);
    // Do NOT show "Ø®Ø·Ø§..." if the user was logged out automatically
    if (err.message === "Unauthorized") {
        // Already handled by forceLogoutIfInvalid()
        return;
    }
    showToast("âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ±. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.");
  } finally {
    exitRestoreLoading();
  }



}

// Remove current fabric (clears image + parts, reorders, selects next)
function handleRemoveFabricClick(){
  // Clear file inputs so re-selecting the same file triggers 'change'
  try{ const _f=document.getElementById('fabFile'); if(_f) _f.value=''; }catch(e){}
  try{ const _c=document.getElementById('fabCam');  if(_c) _c.value=''; }catch(e){}

  if(!fabrics[idx]) return;
  const removedIndex = idx;
  const removedId = fabrics[idx].id;

  // Revoke object URL to free memory
  try{ if(fabrics[idx].url) URL.revokeObjectURL(fabrics[idx].url); }catch(e){}
 // Clear assignments owned by this fabric
  parts.forEach(p=>{ if(assigned[p]===removedId) assigned[p]=null; });

  // Remove fabric slot
  fabrics.splice(idx,1);

  if(fabrics.length===0){
    fabrics.push({id:0,url:'', parts:new Set()});
    idx=0;
  }else{
    // Reindex ids
    fabrics.forEach((f,ii)=>{ f.id=ii; });
    // Shift assigned indices above removedId
    parts.forEach(p=>{ if(assigned[p]!=null && assigned[p]>removedId) assigned[p]=assigned[p]-1; });
    // Select the next fabric after removed (or clamp)
    idx = Math.min(removedIndex, fabrics.length-1);
  }

  showToast("Ù¾Ø§Ø±Ú†Ù‡ Ø­Ø°Ù Ø´Ø¯ â€” Ø¨Ø±Ú†Ø³Ø¨â€ŒÙ‡Ø§ÛŒ Ù…Ø±ØªØ¨Ø· Ù¾Ø§Ú© Ø´Ø¯Ù†Ø¯.");
  updateUI();
}

// ====== NEW: Backend integration & loading state ======
async function sendToBackend(meta, included, baseFile) {
  const form = new FormData();
  form.append("meta", JSON.stringify(meta));
  if (baseFile) form.append("base_image", baseFile);

  for (const it of included) {
    form.append(it.id, it.file);
  }

  // to be removed in the production version
  console.log("Outgoing FormData:", [...form.entries()]);

  let data;
  try {
    ({ data } = await fetchWithAuth("/api/generate", {
      method: "POST",
      body: form
    }));
  } catch {
    throw new Error("Unauthorized");
  }


  if (data?.error === "insufficient_credits") {
    alert(
      `Ø§Ø¹ØªØ¨Ø§Ø± Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª.\n` +
      `Ù…ÙˆØ¬ÙˆØ¯ÛŒ: ${data.credits}\n` +
      `Ù†ÛŒØ§Ø²: ${data.needed}`
    );
    return null;

  }

  if (data?.persistence_failed) {
    showToast("âš ï¸ ØªØµÙˆÛŒØ± Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯. Ø§Ø¹ØªØ¨Ø§Ø±ÛŒ Ø§Ø² Ø´Ù…Ø§ Ú©Ø³Ø± Ù†Ø´Ø¯.");
  }

  return data.image_base64;



}

function enterLoadingState() {
  previewBtn.disabled = true;
  previewBtn.textContent = "â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯...";
  if (baseImg2) baseImg2.style.opacity = "0.4";
}

function exitLoadingState() {
  previewBtn.disabled = false;
  previewBtn.textContent = "âœ¨ Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´";
  if (baseImg2) baseImg2.style.opacity = "1";
}


function enterRestoreLoading() {
  const o = document.getElementById("restoreOverlay");
  if (o) o.style.display = "flex";
}

function exitRestoreLoading() {
  const o = document.getElementById("restoreOverlay");
  if (o) o.style.display = "none";
}




/* ============================== Event Bindings ============================ */

// Hamburger + outside close
hambtn.addEventListener('click', handleHamburgerClick);
document.addEventListener('click', handleDocumentClick);

// Stage navigation
prevStep.addEventListener('click', handlePrevStepClick);
nextBtn.addEventListener('click', handleNextBtnClick);

// Add fabric
addBtn.addEventListener('click', handleAddBtnClick);

// Stage 1 (Upload)
sofaFile.addEventListener('change', handleSofaFileChange);
sofaCam .addEventListener('change', handleSofaCamChange);
toFabricsBtn.addEventListener('click', handleToFabricsClick);

// Stage 2 (Fabrics)
fabFile.addEventListener('change', handleFabFileChange);
fabCam .addEventListener('change', handleFabCamChange);
qToggle.addEventListener('click', handleQToggleClick);
schem  .addEventListener('click', handleSchemClick);

// Generate (Preview)
previewBtn.addEventListener('click', handlePreviewClick);

document.getElementById("backToEditBtn")?.addEventListener("click", () => {
  gotoFabrics();
});

document.getElementById("shareBtn")?.addEventListener("click", async () => {
  if (!outputImg.src) return;

  try {
    await navigator.share({
      title: "Pishnama",
      text: "Ø·Ø±Ø§Ø­ÛŒ Ø§Ù†Ø¬Ø§Ù…â€ŒØ´Ø¯Ù‡ Ø¨Ø§ Ù¾ÛŒØ´Ù†Ù…Ø§",
      url: outputImg.src
    });
  } catch {
    showToast("Ø§Ø´ØªØ±Ø§Ú©â€ŒÚ¯Ø°Ø§Ø±ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯.");
  }
});




// Remove fabric (IIFE in original â†’ direct binding here)
(function bindRemoveFabric(){
  const btn=document.getElementById('removeFabBtn');
  if(!btn) return;
  btn.addEventListener('click', handleRemoveFabricClick);
})();

/* ================================== Init ================================= */

// Ensure we start with an empty fabric slot if needed
(function init(){
  if(fabrics.length===0){
    fabrics.push({id:0,url:'', parts:new Set(['back','seat','arms'])});
    assigned = {back:0, seat:0, arms:0};
    idx=0;
  }
  // Do not call updateUI() here to avoid any visual flicker before user input.
})();

updateLoginButton();

refreshCredits();

</script>

<div id="toast" role="status" aria-live="polite"></div>

<!-- ========================= -->
<!-- "LOGIN MODAL" + "BUY CREDITS MODAL" + "HISTORY MODAL" + "CREATION PREVIEW MODAL" (HIDDEN INIT) -->
<!-- ========================= -->
<div id="loginModal" 
     style="position:fixed; inset:0; background:rgba(0,0,0,0.6); 
            display:none; align-items:center; justify-content:center; z-index:9999;">
  
  <div style="background:#0f162b; padding:20px; border-radius:12px; width:85%; max-width:340px; color:#e5e7eb;">
    <h3 style="margin-top:0;">ÙˆØ±ÙˆØ¯ / Ø«Ø¨Øª Ù†Ø§Ù…</h3>

    <label>Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„:</label>
    <input id="loginIdentifier" style="width:100%; padding:8px; margin:8px 0; border-radius:8px;">
    
    <button id="sendCodeBtn" class="btn primary" style="width:100%; margin-bottom:10px;">Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯</button>

    <label>Ú©Ø¯ Ú†Ù‡Ø§Ø± Ø±Ù‚Ù…ÛŒ:</label>
    <input id="loginCode" maxlength="4" style="width:100%; padding:8px; margin:8px 0; border-radius:8px;">

    <button id="verifyCodeBtn" class="btn" style="width:100%;">ØªØ§ÛŒÛŒØ¯</button>

    <button id="closeLoginModal" class="btn" style="margin-top:10px; width:100%;">Ø¨Ø³ØªÙ†</button>
  </div>
</div>

<div id="buyCreditsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:10000; align-items:center; justify-content:center;">
  <div style="width:min(420px,92vw); background:#0f1629; border:1px solid #3a4367; border-radius:12px; padding:14px;">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
      <div style="font-weight:700;">Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±</div>
      <button class="btn" id="buyCreditsCloseBtn" style="padding:6px 10px;">âœ•</button>
    </div>

    <div style="margin-top:10px; font-size:13px; color:#cbd5e1;">
      (ÙØ¹Ù„Ø§Ù‹ Ø¨Ø¯ÙˆÙ† Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙˆØ§Ù‚Ø¹ÛŒ) ÛŒÚ© Ø¨Ø³ØªÙ‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.
    </div>

    <div style="margin-top:12px; display:flex; flex-direction:column; gap:8px;">
      <button class="btn" data-pack="starter" style="width:100%;">Ø¨Ø³ØªÙ‡ Starter (Ù…Ø«Ù„Ø§Ù‹ 20 Ø§Ø¹ØªØ¨Ø§Ø±)</button>
      <button class="btn" data-pack="plus" style="width:100%;">Ø¨Ø³ØªÙ‡ Plus (Ù…Ø«Ù„Ø§Ù‹ 50 Ø§Ø¹ØªØ¨Ø§Ø±)</button>
      <button class="btn" data-pack="pro" style="width:100%;">Ø¨Ø³ØªÙ‡ Pro (Ù…Ø«Ù„Ø§Ù‹ 120 Ø§Ø¹ØªØ¨Ø§Ø±)</button>
    </div>
  </div>
</div>

<div id="historyModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:10000; overflow:auto;">
  <div style="max-width:900px; margin:40px auto; background:#0f1629; border-radius:12px; padding:16px;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:700;">ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªÙˆÙ„ÛŒØ¯Ù‡Ø§</div>
      <button class="btn" id="historyCloseBtn">âœ•</button>
    </div>

    <div id="historyGrid"
         style="margin-top:16px; display:grid; grid-template-columns:repeat(auto-fill, minmax(160px,1fr)); gap:12px;">
    </div>

    <div style="margin-top:16px; text-align:center;">
      <button class="btn" id="historyLoadMoreBtn">Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨ÛŒØ´ØªØ±</button>
    </div>
  </div>
</div>

<div id="creationPreviewModal"
     style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.7); z-index:10001; overflow:auto;">
  <div style="max-width:900px; margin:40px auto; background:#0f1629; border-radius:12px; padding:16px;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:700;">Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´ ØªÙˆÙ„ÛŒØ¯</div>
      <button class="btn" id="creationPreviewCloseBtn">âœ•</button>
    </div>

    <img id="creationPreviewImage"
         style="width:100%; margin-top:12px; border-radius:10px; display:block;">

    <div id="creationPreviewMeta"
         style="margin-top:12px; font-size:13px; color:#cbd5e1;"></div>
  </div>
</div>





<script>
  
// ============================
// SIMPLE LOGIN HANDLING
// ============================
const loginModal = document.getElementById("loginModal");
const loginBtn = document.getElementById("loginBtn");
const closeLoginModal = document.getElementById("closeLoginModal");
const sendCodeBtn = document.getElementById("sendCodeBtn");
const verifyCodeBtn = document.getElementById("verifyCodeBtn");


const userMenu = document.getElementById("userMenu");
const logoutBtn = document.getElementById("logoutBtn");


const buyCreditsBtn = document.getElementById("buyCreditsBtn");
const buyCreditsModal = document.getElementById("buyCreditsModal");
const buyCreditsCloseBtn = document.getElementById("buyCreditsCloseBtn");

const creationPreviewModal = document.getElementById("creationPreviewModal");
const creationPreviewCloseBtn = document.getElementById("creationPreviewCloseBtn");
const creationPreviewImage = document.getElementById("creationPreviewImage");
const creationPreviewMeta = document.getElementById("creationPreviewMeta");

let lastPreviewedCreation = null;
let previewRequestId = 0;


// Wire buttons & modal behavior (history)
const historyBtn = document.getElementById("historyBtn");
const historyModal = document.getElementById("historyModal");
const historyCloseBtn = document.getElementById("historyCloseBtn");
const historyLoadMoreBtn = document.getElementById("historyLoadMoreBtn");

historyBtn.onclick = () => {
  historyModal.style.display = "block";
  loadHistory(true);
};

historyCloseBtn.onclick = () => {
  historyModal.style.display = "none";
};

historyLoadMoreBtn.onclick = () => {
  loadHistory(false);
};

// Click outside to close
historyModal.addEventListener("click", (e) => {
  if (e.target === historyModal) historyModal.style.display = "none";
});

document.addEventListener("click", (e) => {
  // --- 1) History thumbnail click ---
  const thumb = e.target.closest(".history-thumb");
  if (thumb) {
    openCreationPreview(thumb.dataset.creationId);
    return; // IMPORTANT: stop here so menu logic does not interfere
  }

  // --- 2) Close user menu when clicking outside ---
  if (
    userMenu &&
    !userMenu.contains(e.target) &&
    e.target !== loginBtn
  ) {
    userMenu.style.display = "none";
  }
});





async function openCreationPreview(creationId) {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) return;

  const requestId = ++previewRequestId;
  creationPreviewImage.removeAttribute("src");

  let data;
  try {
    ({ data } = await fetchWithAuth(`/api/creation/${creationId}`));
  } catch {
    return;
  }

  if (requestId !== previewRequestId) return;

  lastPreviewedCreation = data;

  await setImageFromCacheOrFetch(
    creationPreviewImage,
    data.output_full_image_url || data.output_image_url,
    FULL_STORE
  );



  creationPreviewMeta.textContent =
    `Ù†ÙˆØ¹: ${data.mode} | Ú©ÛŒÙÛŒØª: ${data.quality} | ØªØ§Ø±ÛŒØ®: ` +
    new Date(data.created_at).toLocaleDateString("fa-IR");

  creationPreviewModal.style.display = "block";
}

creationPreviewCloseBtn.onclick = () => {
  creationPreviewModal.style.display = "none";
};

creationPreviewModal.addEventListener("click", (e) => {
  if (e.target === creationPreviewModal) {
    creationPreviewModal.style.display = "none";
  }
});


async function fetchUrlAsFile(url, filename) {
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to fetch file: " + url);
  const blob = await res.blob();
  return new File([blob], filename, { type: blob.type || "image/jpeg" });
}

async function restoreSofaFromCreation(c) {

  enterRestoreLoading();
  try{

    // HARD RESET before restore
    fabrics = [];
    idx = 0;
    sofaChosen = false;
    sofaBaseFile = null;

    // ğŸ”’ IMMEDIATE UI CLEAR
    fabImg.src = "";
    fabImg.style.visibility = "hidden";
    baseImg2.src = "";
    sofaThumb.innerHTML = "";
    nextBtn.disabled = true;
    prevStep.disabled = true;
    addBtn.disabled = true;

    // Must have base image
    if (!c.base_image_url) {
      alert("Ø§ÛŒÙ† ØªÙˆÙ„ÛŒØ¯ Ù‚Ø¯ÛŒÙ…ÛŒ Ø§Ø³Øª Ùˆ ØªØµÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡ Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
      return;
    }

    // 1) Go to fabrics step UI (removed)
    

    // 2) Restore base image preview + file
    const baseFile = await fetchUrlAsFile(c.base_image_url, "base.jpg");

    sofaBaseFile = baseFile;          // your existing variable in sofa workflow
    sofaChosen = true;                // your existing state
    sofaThumb.innerHTML = '<img>';
    loadImage(sofaThumb.firstElementChild, baseFile); // stage 1 preview
    loadImage(baseImg2, baseFile);    // stage 2 preview

        // 3+4) Rebuild fabrics + restore parts using ROLE/ID mapping (NOT index-based)
    // This prevents c.fabrics[] and c.meta.fabrics[] ordering mismatches.

    // Build: role -> File
    const filesByRole = {};
    for (let i = 0; i < (c.fabrics || []).length; i++) {
      const f = c.fabrics[i];
      if (!f || !f.image_url) continue;

      const role =
        (typeof f.role === "string" && f.role) ||
        `fabric_${String(i + 1).padStart(2, "0")}`;

      filesByRole[role] = await fetchUrlAsFile(f.image_url, `${role}.jpg`);
    }

    // Build: role/id -> parts[]
    const partsByRole = {};
    if (c.meta && Array.isArray(c.meta.fabrics)) {
      for (const mf of c.meta.fabrics) {
        if (!mf || typeof mf.id !== "string") continue;
        if (!Array.isArray(mf.parts)) continue;
        partsByRole[mf.id] = mf.parts.slice();
      }
    }

    // Decide roles in stable order (01,02,03), include only ones we actually have an image for
    const ORDER = ["fabric_01", "fabric_02", "fabric_03"];
    const rolesToUse = ORDER.filter(r => !!filesByRole[r]);

    // Fallback: if server uses nonstandard roles, include any extra roles too (stable-ish)
    if (rolesToUse.length === 0) {
      const extraRoles = Object.keys(filesByRole).sort();
      rolesToUse.push(...extraRoles);
    }

    // Build fabrics array in UI slot order
    fabrics = rolesToUse.map((role, slotIdx) => {
      const file = filesByRole[role];
      const url = URL.createObjectURL(file);

      const p = Array.isArray(partsByRole[role]) ? partsByRole[role] : [];
      return {
        id: slotIdx,
        url,
        file,
        parts: new Set(p)
      };
    });

    // Rebuild assigned map from restored fabric.parts
    assigned = { back: null, seat: null, arms: null };
    for (const fab of fabrics) {
      if (!fab || !fab.parts) continue;
      fab.parts.forEach(p => {
        assigned[p] = fab.id;
      });
    }


    
    // 5) Reset current fabric index and sync UI
    idx = 0;

    // âœ… symmetry with fresh flow (so Stage-1 "Continue" is not stuck disabled after restore)
    toFabricsBtn.disabled = false;

    gotoFabrics(); // stage 2 + updateUI()

    // ğŸ”“ RE-ENABLE UI AFTER RESTORE (other enable/disable is handled by updateUI)
    prevStep.disabled = false;

    await Promise.all([
      waitForImage(sofaThumb.querySelector("img")),
      waitForImage(baseImg2)
    ]);

  } finally {
    exitRestoreLoading();
  }
  

  
}









function isValidEmail(str) {
    return /\S+@\S+\.\S+/.test(str);
}

function isValidPhone(str) {
    return /^09\d{9}$/.test(str);
}

function normalizePhone(str) {
    // input: 09123456789 â†’ output: +989123456789
    if (isValidPhone(str)) {
        return "+98" + str.slice(1);
    }
    return str;
}


// Toggle user menu when clicking the identifier (loginBtn)
loginBtn.onclick = () => {
    const token = localStorage.getItem("pishnama_user_token");
    if (token) {
        // User is logged in â†’ show/hide menu
        userMenu.style.display = 
            userMenu.style.display === "block" ? "none" : "block";
    } else {
        // User not logged in â†’ open login modal
        loginModal.style.display = "flex";
    }
};

logoutBtn.onclick = async () => {
    // Clear stored credentials
    localStorage.removeItem("pishnama_user_token");
    localStorage.removeItem("pishnama_user_identifier");
    await clearImageCache();

    // Update UI
    updateLoginButton();

    // Hide menu
    userMenu.style.display = "none";

    // Optional user feedback
    showToast("Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯.");

    document.getElementById("historyGrid").innerHTML = "";
    historyPage = 1;

    lastPreviewedCreation = null;
    creationPreviewModal.style.display = "none";


};

closeLoginModal.onclick = () => loginModal.style.display = "none";

function openBuyCreditsModal() {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) {
    alert("Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±ØŒ Ù„Ø·ÙØ§Ù‹ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.");
    loginModal.style.display = "flex";
    return;
  }
  buyCreditsModal.style.display = "flex";
}

function closeBuyCreditsModal() {
  buyCreditsModal.style.display = "none";
}

async function buyCredits(packageId, confirmBurn = false) {
  let data;
  try {
    ({ data } = await fetchWithAuth("/api/buy-credits", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        package: packageId,
        confirm_burn: confirmBurn
      })
    }));
  } catch {
    return; // login_required already handled
  }

  if (data?.requires_confirmation) {
    const ok = confirm(
      data?.message ||
      "ØªØ¹Ø¯Ø§Ø¯ÛŒ Ø§Ø² Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ÛŒ ÙØ¹Ù„ÛŒ Ø´Ù…Ø§ Ù…ÛŒâ€ŒØ³ÙˆØ²Ø¯. Ø§Ø¯Ø§Ù…Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒØ¯ØŸ"
    );
    if (!ok) return;
    return buyCredits(packageId, true);
  }

  if (data?.error) {
    alert(data.error);
    return;
  }

  alert("âœ… Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.");
  closeBuyCreditsModal();
  refreshCredits();
}


buyCreditsBtn?.addEventListener("click", openBuyCreditsModal);
buyCreditsCloseBtn?.addEventListener("click", closeBuyCreditsModal);

// Click outside card closes
buyCreditsModal?.addEventListener("click", (e) => {
  if (e.target === buyCreditsModal) closeBuyCreditsModal();
});

// Package buttons
buyCreditsModal?.querySelectorAll("[data-pack]")?.forEach(btn => {
  btn.addEventListener("click", () => buyCredits(btn.dataset.pack));
});


// Send code
sendCodeBtn.onclick = async () => {
  let identifier = document.getElementById("loginIdentifier").value.trim();
  if (!identifier) return alert("Ù„Ø·ÙØ§Ù‹ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.");

  if (!isValidEmail(identifier) && !isValidPhone(identifier)) {
      return alert("Ù„Ø·ÙØ§ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø±Ø§ Ø§ØµÙ„Ø§Ø­ ÙØ±Ù…Ø§ÛŒÛŒØ¯");
  }

  // Normalize phone to +98 format for backend
  identifier = normalizePhone(identifier);

  await fetch("/api/request-code", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({identifier})
  });

  alert("Ú©Ø¯ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.");

};

// Verify
verifyCodeBtn.onclick = async () => {

  let identifier = document.getElementById("loginIdentifier").value.trim();
  if (!isValidEmail(identifier) && !isValidPhone(identifier)) {
      return alert("Ù„Ø·ÙØ§ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø±Ø§ Ø§ØµÙ„Ø§Ø­ ÙØ±Ù…Ø§ÛŒÛŒØ¯");
  }
  // normalize before sending to backend
  identifier = normalizePhone(identifier);
  

  const code = document.getElementById("loginCode").value.trim();

  const res = await fetch("/api/verify-code", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({identifier, code})
  });

  const data = await res.json();
  if (!data.token) return alert("Ú©Ø¯ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª.");

  // Save token + identifier
  localStorage.setItem("pishnama_user_token", data.token);
  localStorage.setItem("pishnama_user_identifier", identifier);

  // Close modal
  alert("ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯!");
  loginModal.style.display = "none";

  // Update UI
  updateLoginButton();

  refreshCredits();

};




window.addEventListener("storage", (e) => {
    if (e.key === "pishnama_user_token") {
        updateLoginButton();
        userMenu.style.display = "none";  // closes the user dropdown menu in other tabs after logout
        loginModal.style.display = "none";   // closes login panel in other tabs
    }

    if (localStorage.getItem("pishnama_user_token")) {
      refreshCredits();            // login in another tab
    } else {
      const ci = document.getElementById("credit-info");
      if (ci) { ci.textContent = ""; ci.style.display = "none"; }
    }

    // =========================
    // Theme sync across tabs
    // =========================
    if (e.key === "pishnama_theme") {
        const theme = e.newValue || "dark";
        document.documentElement.setAttribute("data-theme", theme);

        const btn = document.getElementById("themeToggleBtn");
        if (btn) {
            btn.textContent = theme === "dark"
              ? "â˜€ï¸ Ø­Ø§Ù„Øª Ø±ÙˆØ´Ù†"
              : "ğŸŒ™ Ø­Ø§Ù„Øª ØªÛŒØ±Ù‡";
        }
    }



});

</script>

<script>
/* =========================
   Theme toggle with OS detect + icon swap
========================= */
(function initThemeToggle(){
  const KEY = "pishnama_theme";
  const btn = document.getElementById("themeToggleBtn");

  function apply(theme){
    document.documentElement.setAttribute("data-theme", theme);
    if (btn) {
      btn.textContent = theme === "dark"
        ? "â˜€ï¸ Ø­Ø§Ù„Øª Ø±ÙˆØ´Ù†"
        : "ğŸŒ™ Ø­Ø§Ù„Øª ØªÛŒØ±Ù‡";
    }
  }

  function detectOSTheme(){
    return window.matchMedia &&
           window.matchMedia("(prefers-color-scheme: dark)").matches
           ? "dark"
           : "light";
  }

  // Priority:
  // 1) User choice
  // 2) OS preference
  const saved = localStorage.getItem(KEY);
  const initial = saved || detectOSTheme();
  apply(initial);

  if (btn) {
    btn.addEventListener("click", () => {
      const current =
        document.documentElement.getAttribute("data-theme") || initial;
      const next = current === "dark" ? "light" : "dark";
      localStorage.setItem(KEY, next);
      apply(next);
    });
  }
})();
</script>



<!-- Base Images Album Modal -->
<div id="baseAlbumModal">
  <div id="baseAlbumCard">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:700;">Ø¢Ù„Ø¨ÙˆÙ… ØªØµØ§ÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡</div>
      <button class="btn" id="closeBaseAlbumBtn">âœ•</button>
    </div>

    <div id="baseAlbumGrid"></div>

    <div style="margin-top:16px; text-align:center;">
      <button class="btn" id="loadMoreBaseImagesBtn">Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨ÛŒØ´ØªØ±</button>
    </div>
  </div>
</div>

<script>
(function initBaseAlbum(){
  let baseAlbumPage = 1;
  const BASE_PAGE_SIZE = 24;

  const openBtn  = document.getElementById("openBaseAlbumBtn");
  const modal    = document.getElementById("baseAlbumModal");
  const card     = document.getElementById("baseAlbumCard");
  const closeBtn = document.getElementById("closeBaseAlbumBtn");
  const grid     = document.getElementById("baseAlbumGrid");
  const moreBtn  = document.getElementById("loadMoreBaseImagesBtn");

  if (!openBtn || !modal || !grid || !moreBtn || !closeBtn) return;

  function openModal(){
    baseAlbumPage = 1;
    grid.innerHTML = "";
    modal.style.display = "flex";
    loadPage();
  }

  function closeModal(){
    modal.style.display = "none";
  }

  // close when clicking outside the card
  modal.addEventListener("click", (e) => {
    if (e.target === modal) closeModal();
  });

  openBtn.addEventListener("click", openModal);
  closeBtn.addEventListener("click", closeModal);

  moreBtn.addEventListener("click", () => {
    baseAlbumPage++;
    loadPage();
  });

  async function fetchAndCacheImage(url, storeName){
    const cached = await getCachedBlob(storeName, url);
    if (cached) return cached;

    const blob = await fetchImageBlobWithAuth(url);
    if (!blob) return null;

    await setCachedBlob(storeName, url, blob);
    return blob;
  }

  function setBaseImageFromBlob(blob){
    const file = new File([blob], "base.jpg", { type: blob.type || "image/jpeg" });
    const dt = new DataTransfer();
    dt.items.add(file);

    const input = document.getElementById("sofaFile");
    if (!input) return;

    input.files = dt.files;
    input.dispatchEvent(new Event("change"));
  }

  async function loadPage(){
    let data;
    try {
      ({ data } = await fetchWithAuth(`/api/base-images?page=${baseAlbumPage}&pageSize=${BASE_PAGE_SIZE}`));
    } catch {
      return; // auth handler already ran
    }

    for (const item of (data.items || [])) {
      const img = document.createElement("img");
      img.className = "baseAlbumThumb";
      img.alt = "base";

      // thumbs
      if (item.thumb_url) {
        await setImageFromCacheOrFetch(img, item.thumb_url, THUMB_STORE);
      } else if (item.full_url) {
        // fallback: show full as thumb (still cached in THUMB store if possible)
        await setImageFromCacheOrFetch(img, item.full_url, THUMB_STORE);
      }

      img.addEventListener("click", async () => {
        if (!item.full_url) return;

        const blob = await fetchAndCacheImage(item.full_url, FULL_STORE);
        if (!blob) return;

        setBaseImageFromBlob(blob);
        closeModal();
      });

      grid.appendChild(img);
    }

    // hide "more" if no more items reported
    if (typeof data.total === "number") {
      const shown = grid.children.length;
      moreBtn.style.display = shown < data.total ? "inline-block" : "none";
    }
  }
})();
</script>


<!-- =========================
     Fabrics Album Modal
========================= -->
<div id="fabricAlbumModal" style="
  position:fixed; inset:0;
  background:rgba(0,0,0,.6);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:10060;
">
  <div id="fabricAlbumCard" style="
    width:min(900px,92vw);
    max-height:85vh;
    overflow:auto;
    background:#0f1629;
    border:1px solid #3a4367;
    border-radius:12px;
    padding:16px;
  ">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Ø¢Ù„Ø¨ÙˆÙ… Ù¾Ø§Ø±Ú†Ù‡â€ŒÙ‡Ø§</strong>
      <button class="btn" id="closeFabricAlbumBtn">âœ•</button>
    </div>

    <div id="fabricAlbumGrid"
         style="
           margin-top:16px;
           display:grid;
           grid-template-columns:repeat(auto-fill,minmax(120px,1fr));
           gap:12px;
         ">
    </div>

    <div style="margin-top:16px;text-align:center">
      <button class="btn" id="loadMoreFabricBtn">Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨ÛŒØ´ØªØ±</button>
    </div>
  </div>
</div>


</body>
</html>
