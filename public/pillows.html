<!doctype html>
<!--
  Project: Pishnama â€” Sofa Fabric Assignment (Developer-Commented Copy)
  File: sofa_commented_dev.html
  Purpose:
    Two-stage flow to upload a sofa image and assign up to THREE fabrics to specific parts
    of the sofa (back/seat/arms). Uses pure HTML/CSS/vanilla JS. No network calls here.

  Key UX decisions (preserve behavior exactly):
    â€¢ Hamburger is icon-only (â˜°). Menu contains links to sofa & pillows pages.
    â€¢ File selection buttons are icon-only (ğŸ“ for choose file, ğŸ“· for camera).
    â€¢ Stages:
        1) Upload: user selects base sofa image; "Continue" becomes enabled after image loads.
        2) Fabrics: user iterates through per-fabric context and assigns fabric to parts.
    â€¢ Up to 3 fabrics are supported. The "Add Fabric" button:
        â€“ Shows â€œâ• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ {Ø¯ÙˆÙ…|Ø³ÙˆÙ…}â€ (dynamic ordinal)
        â€“ Is completely HIDDEN when three fabrics already exist (NOT disabled).
    â€¢ Placeholder text â€œÙ¾Ø§Ø±Ú†Ù‡ {Ø§ÙˆÙ„|Ø¯ÙˆÙ…|Ø³ÙˆÙ…} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯â€ appears inside the preview
      until the current fabric image is set.
    â€¢ â€œØ¨Ø®Ø´ Ù…Ø±Ø¨ÙˆØ·Ù‡â€ (part grid) controls assignment; a fabric can own any subset of parts.
      Visibility rules prevent conflicting assignments across fabrics.
    â€¢ â€œNextâ€ is always rendered (visible) but disabled when there is no next fabric.
    â€¢ â€œPreviewâ€ enables only when at least one part is selected for the current fabric.
  Notes for future devs:
    â€¢ Blob URLs (createObjectURL) are used for local previews; revoke on <img> load where applicable.
    â€¢ This page is self-contained UI only; model integration should be added where Preview is handled.
-->
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Ù¾ÛŒØ´Ù†Ù…Ø§ â€” Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</title>
<style>
  :root{--bg:#0b1020;--card:#0f162b;--muted:#94a3b8;--text:#e5e7eb;--border:#243045;--accent:#22c55e;--blue:#1f3a8a}
  html,body{margin:0;background:var(--bg);color:var(--text);font-family:Vazirmatn,IRANSans,Segoe UI,Roboto,Arial}
  .wrap{max-width:480px;margin:0 auto;min-height:100svh;/* replaced */ height:auto;/* added */display:flex;flex-direction:column}
  .bar{position:relative;padding:10px 14px;display:flex;justify-content:flex-start;align-items:center}
  /* Icon-only hamburger; text "Ù…Ù†Ùˆ" intentionally removed */
  .hamburger{border:1px solid var(--border);background:#0f1a33;color:#e2e8f0;border-radius:10px;padding:8px 12px;cursor:pointer}
  .menu{position:absolute;top:48px;right:14px;background:var(--card);border:1px solid var(--border);border-radius:12px;min-width:180px;display:none;flex-direction:column;overflow:hidden;z-index:10}
  .menu a{padding:10px 12px;color:#e5e7eb;text-decoration:none;border-bottom:1px solid var(--border);display:block}
  .menu a:last-child{border-bottom:0}
  .menu.show{display:flex}

  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;margin:10px}
  .row{display:flex;align-items:center;gap:8px}
  .btn{border:1px solid var(--border);background:#0f1a33;color:#e2e8f0;border-radius:12px;padding:10px 14px;cursor:pointer}
  .btn.primary{background:var(--blue);border-color:var(--blue)}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  /* Generic image frame for previews/placeholders */
  .thumb{position:relative;display:flex;align-items:center;justify-content:center;border:1px solid var(--border);border-radius:12px;min-height:120px;background:#0f172a;overflow:hidden}
  .thumb img{max-width:100%;max-height:100%;width:auto;height:auto;display:block}
  .badge{position:absolute;top:8px;right:8px;background:#0f1a33;border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:.85rem;color:#e5e7eb}

  /* Quality toggle (two-state) */
  .toggle{display:inline-flex;border:1px solid var(--border);border-radius:999px;overflow:hidden}
  .toggle button{border:0;background:transparent;color:#cbd5e1;padding:8px 12px}
  .toggle .active{background:#193a88;color:#fff}

  /* Mode selection */
  .schem{
    display:flex;
    flex-direction:row;     
    gap:8px;
    margin-top:6px;
    justify-content:space-between;
    align-items:stretch;
  }
  .part{
    flex:1;
    min-height:56px;
    border:1px solid var(--border);
    border-radius:10px;
    background:#0f1a33;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:10px;
    text-align:center;
    line-height:1.4;
  }
  .part.active{
    background:#0e3a2b;
    border-color:#0e3a2b;
  }


  .viewport{flex:1;display:flex;flex-direction:column;gap:10px;overflow:auto/*replaced*/}
  .section{display:none;flex:1;overflow:auto/*replaced*/}
  .section.active{display:flex;flex-direction:column}

  .controls{margin:0 10px;display:flex;flex-direction:column;gap:10px;flex:1}
  .rightline{display:flex;justify-content:flex-start;align-items:center}
  .between{display:flex;justify-content:space-between;align-items:center}

  /* Fabric selection frame borrowed from pillows layout */
  .selectFrame{border:1px solid var(--border);border-radius:12px;padding:10px;background:#0f172a;display:flex;flex-direction:column;gap:10px;position:relative}

  /* Fixed heights used in mobile-safe viewport */
  #sofaThumb, #baseFrame { height: 220px !important; width: 100%; }
  #navRow{margin:0 10px;display:flex;justify-content:space-between;align-items:center}
  .tagsHeader{margin-top:14px;margin-bottom:6px;font-size:.95rem;color:var(--muted);}

  /* Tiny remove icon inside fabric frame */
  .tinyX{position:absolute;left:8px;top:8px;background:#0f1a33;border:1px solid var(--border);border-radius:8px;padding:4px 6px;cursor:pointer;font-size:14px;line-height:1}
  .tinyX:hover{background:#17213d}
  /* Toast */
  #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0f1a33;border:1px solid var(--border);color:#e5e7eb;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .25s;pointer-events:none;z-index:9999}
  #toast.show{opacity:1}

</style>
<script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
</head>
<body>
<div class="wrap">
  <!-- Header: hamburger only -->
  <div class="bar">
    <button class="hamburger" id="hambtn">â˜°</button>
    <div class="menu" id="menu">
      <a href="sofa.html">ğŸ›‹ï¸ Ø·Ø±Ø§Ø­ÛŒ Ù…Ø¨Ù„</a>
      <a href="pillows.html">ğŸ›‹ï¸ Ø·Ø±Ø§Ø­ÛŒ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</a>
    </div>
  </div>

  <div class="viewport">
    <!-- ===== Stage 1: Upload base sofa image ===== -->
    <section id="step-upload" class="section active">
      <div class="card">
        <h3 style="margin:0 0 8px">ğŸ“· Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ± "Ù…Ø¨Ù„ Ùˆ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§"</h3>
        <div class="thumb" id="sofaThumb">
          <!-- <span class="hint">Ù‡Ù†ÙˆØ² ØªØµÙˆÛŒØ±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡</span> -->
        </div>

        <div class="controls" style="margin-top: 8px;margin-right: 0px;margin-left: 0px;">
        <div class="row between">
          <!-- Icon-only file/camera per product decision -->
          <div class="row">
            <label class="btn" title="Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„">ğŸ“<input id="sofaFile" type="file" accept="image/*" hidden></label>
            <label class="btn" title="Ø¯ÙˆØ±Ø¨ÛŒÙ†">ğŸ“·<input id="sofaCam" type="file" accept="image/*" capture="environment" hidden></label>
          </div>
          <!-- Continue becomes enabled only after the image loads -->
          <button class="btn primary" id="toFabricsBtn" disabled>Ø§Ø¯Ø§Ù…Ù‡ â—€</button>
        </div>
      </div>

      </div>

    </section>

    <!-- ===== Stage 2: Fabric selection + part assignment ===== -->
    <section id="step-fabrics" class="section">
      <!-- Navigation row: â€œPrevâ€ always goes back to stage 1 if idx==0; â€œNextâ€ is visible but disabled if no next -->
      <div class="row" id="navRow">
        <button class="btn" id="prevStep">Ù‚Ø¨Ù„ÛŒ â–¶</button>
        <button class="btn" id="nextBtn">â—€ Ø¨Ø¹Ø¯ÛŒ</button>
      </div>

      <div class="card" id="frame">
        <!-- Stage 2 base sofa frame mirrors pillows layout -->
        <div class="thumb" id="baseFrame" style="margin-bottom: 15px;">
          <img id="baseImg2" alt="">
        </div>

        <!-- Fabric selection frame with thumbnail + controls -->
        <div class="selectFrame">
          <button class="tinyX" id="removeFabBtn" title="Ø­Ø°Ù Ù¾Ø§Ø±Ú†Ù‡">ğŸ—‘ï¸</button>
          <!-- I commented this line and the related codes - I will probably delete it in the future (search wizBadge to find related codes) -->
          <!-- <span class="badge" id="wizBadge" style="display: none;">Ù¾Ø§Ø±Ú†Ù‡ 1 Ø§Ø² 1</span> -->
          <div class="row" style="justify-content:flex-start;width:100%">
            <strong id="selTitle" style="color:var(--muted);font-size:.95rem;">Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø§Ø±Ú†Ù‡ Ø§ÙˆÙ„</strong>
          </div>
          <div class="row" style="justify-content:space-between;width:100%">
            <div class="rightline" style="gap:8px">
              <label class="btn" title="Ø¢Ù¾Ù„ÙˆØ¯ Ù¾Ø§Ø±Ú†Ù‡">ğŸ“<input id="fabFile" type="file" accept="image/*" hidden></label>
              <label class="btn" title="Ø¯ÙˆØ±Ø¨ÛŒÙ†">ğŸ“·<input id="fabCam" type="file" accept="image/*" capture="environment" hidden></label>
            </div>
            <img id="fabImg" alt="" style="width:36px;height:36px;border-radius:8px;border:1px solid var(--border);object-fit:cover;background:#0f172a;visibility:hidden">
          </div>
          <!-- I commented this line and the related codes - I will probably delete it in the future (search fabPlaceholder to find related codes) -->
          <!-- <span id="fabPlaceholder" style="color:var(--muted);font-size:.9rem;display:block;">Ù¾Ø§Ø±Ú†Ù‡ Ø§ÙˆÙ„ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</span> -->
          <div>
            <div class="tagsHeader" style="margin-top:0">Ø­Ø§Ù„Øª Ø§Ø¹Ù…Ø§Ù„ Ù¾Ø§Ø±Ú†Ù‡ Ø±ÙˆÛŒ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</div>
            <div class="schem" id="schem">
              <button class="part" data-mode="single" style="color: #e2e8f0;">ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</button>
              <button class="part" data-mode="random" style="color: #e2e8f0;">Ø¯Ùˆ ÛŒØ§ Ø³Ù‡ Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ù‡â€ŒØµÙˆØ±Øª ØªØµØ§Ø¯ÙÛŒ</button>
            </div>
          </div>
        </div>
        <!-- Add Fabric: HIDDEN when fabrics.length >= 3; otherwise enabled based on selection readiness -->
        <div class="controls">
          <div class="rightline" style="margin-top: 10px;">
            <button class="btn" id="addBtn">â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ Ø¯ÙˆÙ…</button>
          </div>
        </div>
      </div>

      

      <!-- Generate row: quality toggle + preview (integration point for the model) -->
      <div class="controls">
        <div class="rightline" style="gap:8px; margin-bottom: 20px; margin-top: 10px;">
          <div class="toggle" id="qToggle" style="margin-left: 10px;">
            <button class="active" data-q="high">Ù‡ÙˆØ´ ÛŒÚ© &nbsp; (2 Ø³Ú©Ù‡)</button>
            <button data-q="standard">Ù‡ÙˆØ´ Ø¯Ùˆ &nbsp; (1 Ø³Ú©Ù‡)</button>
          </div>
          <button class="btn primary" id="previewBtn">âœ¨ Ø¨Ø³Ø§Ø²</button>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
/* =============================================================================
   Pishnama â€” Sofa Page (Inline Script, Refactored)
   Scope: Internal modularization & comments ONLY â€” ZERO behavior/UI changes
   Notes:
     - Public IDs/classes and Persian text are untouched.
     - Structure: Typedefs â†’ Constants/DOM â†’ State â†’ Helpers â†’ Core UI Sync
                  â†’ Validation/Export â†’ Handlers â†’ Event Bindings â†’ Init
============================================================================= */

/** ============================================================================
 * Typedefs (documentation only)
 * @typedef {{ id:number, url:string, file?:File }} Fabric
 * ========================================================================== */

/* ============================== Constants / DOM ============================ */

// Maps 1..3 to Persian ordinals: Ø§ÙˆÙ„ / Ø¯ÙˆÙ… / Ø³ÙˆÙ…
function faOrdinal(n){ return n===1?'Ø§ÙˆÙ„':(n===2?'Ø¯ÙˆÙ…':'Ø³ÙˆÙ…'); }

// Hamburger
const hambtn   = document.getElementById('hambtn');
const menu     = document.getElementById('menu');

// Stage 1 (Upload)
const sofaFile     = document.getElementById('sofaFile');
const sofaCam      = document.getElementById('sofaCam');
const sofaThumb    = document.getElementById('sofaThumb');
const toFabricsBtn = document.getElementById('toFabricsBtn');
const stepUpload   = document.getElementById('step-upload');

// Stage 2 (Fabrics)
const stepFabrics  = document.getElementById('step-fabrics');
const baseImg2     = document.getElementById('baseImg2');
const fabFile      = document.getElementById('fabFile');
const fabCam       = document.getElementById('fabCam');
const fabImg       = document.getElementById('fabImg');
const selTitle     = document.getElementById('selTitle');
// const wizBadge     = document.getElementById('wizBadge');
const qToggle      = document.getElementById('qToggle');
const schem        = document.getElementById('schem');
const previewBtn   = document.getElementById('previewBtn');
const addBtn       = document.getElementById('addBtn');
const nextBtn      = document.getElementById('nextBtn');
const prevStep     = document.getElementById('prevStep');



/* ================================== State ================================= */

// Global UI state (no persistence)
let sofaChosen   = false; // becomes true after an image is picked
/** @type {Fabric[]} */
let fabrics      = [];    // each item: { id, url, file?:File }
let idx          = 0;     // index of "current" fabric being edited
let sofaBaseFile = null;  // keep original base sofa File for export

// NEW: Global quality setting (standard | high)
let generationQuality = "high";

// NEW: pillows mode selection: "single" | "random"
let modeSelection = "single";   // default selection


/* =============================== Helpers ================================== */

/** Set <img>.src with a Blob URL; revoke URL after load to avoid leaks */
function loadImage(el, file){
  const url = URL.createObjectURL(file);
  el.src = url;
  el.onload = () => URL.revokeObjectURL(url);
}

/** Stage navigation (no side effects beyond DOM visibility) */
function gotoUpload(){
  stepFabrics.classList.remove('active');
  stepUpload.classList.add('active');
}
function gotoFabrics(){
  stepUpload.classList.remove('active');
  stepFabrics.classList.add('active');
  updateUI();
}

/* ============================== Core UI Sync ============================== */
/*
  Responsibilities:
    1) Update preview image + placeholder text
    2) Update part grid visibility/active states under conflicting assignments
    3) Manage â€œAdd Fabricâ€ (show/hide + label + enabled state)
    4) Keep â€œNextâ€ visible but disabled when there is no next fabric
    5) Enable Preview (generate) â€” validation happens on click
*/
function updateUI(){
  if(!fabrics[idx]) return;
  const cur = fabrics[idx];

  // 1) Preview (image or ordinal placeholder)
  fabImg.src = cur.url || '';
  fabImg.style.visibility = cur.url ? 'visible' : 'hidden';
  // const ph = document.getElementById('fabPlaceholder');
  // if(cur.url){ ph.style.display='none'; }
  // else { ph.textContent = `Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(idx+1)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯`; ph.style.display='block'; }
  if(selTitle){ selTitle.textContent = `Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(idx+1)}`; }

  // Wizard badge: "Ù¾Ø§Ø±Ú†Ù‡ X Ø§Ø² N"
  // wizBadge.textContent = `Ù¾Ø§Ø±Ú†Ù‡ ${idx+1} Ø§Ø² ${fabrics.length}`;


  // Hide or show the mode title based on stage
  const modeTitle = document.querySelector('.tagsHeader');
  if (modeTitle) {
      modeTitle.style.display = (idx === 0 ? 'block' : 'none');
  }

  // 2) Mode buttons visibility & active state
  if (schem) {
    schem.querySelectorAll('.part').forEach(btn => {
      if (idx === 0) {
        btn.style.display = 'block';
        const m = btn.dataset.mode;
        btn.classList.toggle('active', modeSelection === m);
      } else {
        // On fabric #2 and #3, hide the mode buttons completely
        btn.style.display = 'none';
      }
    });
  }

  // 5) Generate is always enabled; validation happens on click now
  previewBtn.disabled = false;

  // 3) Add Fabric management (depends on mode)
  const multiAllowed = (modeSelection === 'random');
  if (!multiAllowed) {
    // In single mode (or before choosing a mode), hide the Add button
    addBtn.style.display = 'none';
  } else {
    if (fabrics.length >= 3) {
      addBtn.style.display = 'none';
    } else {
      addBtn.style.display = 'inline-block';
      const nextOrdinal = faOrdinal(Math.min(fabrics.length+1,3));
      addBtn.textContent = `â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ ${nextOrdinal}`;

      const currentReady = !!cur.url; // only need an image, no parts
      addBtn.disabled = !currentReady;
    }
  }

  // 4) Next button: always present; disabled if there is no next fabric
  nextBtn.style.display='inline-block';
  nextBtn.disabled = !(idx < fabrics.length-1);
}

/* ===================== Validation (pre-generation) ======================== */

function validateBeforeGenerateSofa(){
  const errors = [];
  const warnings = [];

  // Base image is required
  if(!sofaChosen){
    errors.push("\n- ØªØµÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡Ù” Ù…Ø¨Ù„ Ùˆ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
  }

  const fabricsWithImg = fabrics.filter(f => !!f.url);

  if(fabricsWithImg.length === 0){
    errors.push("\n- Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ØªØµÙˆÛŒØ± Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ø§ÛŒØ¯ Ø¢Ù¾Ù„ÙˆØ¯ Ø´ÙˆØ¯.");
  }

  if(!modeSelection){
    errors.push("\n- Ø¨Ø§ÛŒØ¯ ÛŒÚ©ÛŒ Ø§Ø² Ø¯Ùˆ Ø­Ø§Ù„Øª Â«Ù‡Ù…Ù‡Ù” Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§ Ø¨Ø§ ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡Â» ÛŒØ§ Â«ØªØ§ Ø³Ù‡ Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ù‡â€ŒØµÙˆØ±Øª ØªØµØ§Ø¯ÙÛŒÂ» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.");
  }

  if(modeSelection === 'single' && fabricsWithImg.length > 1){
    warnings.push("\n- Ø¯Ø± Ø­Ø§Ù„Øª Â«Ù‡Ù…Ù‡Ù” Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§ Ø¨Ø§ ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡Â» ÙÙ‚Ø· Ù¾Ø§Ø±Ú†Ù‡Ù” Ø§ÙˆÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Ø¨Ù‚ÛŒÙ‡ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø®ÙˆØ§Ù‡Ù†Ø¯ Ø´Ø¯.");
  }

  // Random mode warnings (updated logic)
  // Only 1 fabric â†’ warn because it will auto-switch to single mode
  if (modeSelection === 'random' && fabricsWithImg.length === 1) {
      warnings.push("\n- ÙÙ‚Ø· ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ø¯Ø± ØµÙˆØ±Øª Ø§Ø¯Ø§Ù…Ù‡ØŒ Ø­Ø§Ù„Øª Â«ØªØµØ§Ø¯ÙÛŒÂ» Ø¨Ù‡â€ŒØµÙˆØ±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ø¨Ù‡ Â«ØªÚ©â€ŒÙ¾Ø§Ø±Ú†Ù‡Â» ØªØºÛŒÛŒØ± Ù…ÛŒâ€ŒÚ©Ù†Ø¯.");
  }
  // 2 or 3 fabrics â†’ valid random mode â†’ no warning


  return {errors, warnings};
}

/* ========================== Export / ZIP Helpers ========================== */

function tsNow(){
  const p = new Date();
  const z = n=>String(n).padStart(2,'0');
  return `${p.getFullYear()}-${z(p.getMonth()+1)}-${z(p.getDate())}_${z(p.getHours())}-${z(p.getMinutes())}-${z(p.getSeconds())}`;
}
function ext(name){
  const i = name.lastIndexOf('.'); return i>=0 ? name.slice(i) : '.png';
}
function downloadBlob(blob, filename){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(blob);
  a.download=filename;
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2500);
}

/** Build meta/files overview WITHOUT side effects (pure builder) */
function buildSofaMetaAndFiles(){
  // use global quality (no longer read from DOM)
  const quality = generationQuality;

  const included = [];
  const excluded = [];
  // Determine which fabrics should be included based on mode
  let fabricListToInclude = [];

  if (modeSelection === "single") {
    // Only the first fabric (index 0)
    fabricListToInclude = fabrics.slice(0, 1);
  } else {
    // Random mode â†’ include all fabrics with images
    fabricListToInclude = fabrics;
  }

  // Build include/exclude lists
  fabricListToInclude.forEach((f, fi) => {
    const id = `fabric_${String(fi+1).padStart(2,'0')}`;
    const hasFile = !!f.file;
    if (hasFile) {
      included.push({ id, file: f.file });
    } else {
      excluded.push({ id, reason: 'no image' });
    }
  });


  const selMode = modeSelection || 'single';

  const meta = {
    mode: 'pillows',
    mode_selection: selMode,
    quality,
    fabrics: included.map(x=>({id:x.id})),
    excluded,
    files: {
      base_image: sofaBaseFile ? 'base_image'+ext(sofaBaseFile.name) : null,
      fabrics: included.map(x=> x.id + ext(x.file.name))
    }
  };

  const lines = [];
  const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'local';
  lines.push('=== HEADER ===');
  lines.push('mode: pillows');
  lines.push(`mode_selection: ${selMode}`);
  lines.push(`timestamp: ${new Date().toLocaleString()} (${tz})`);
  lines.push(`quality: ${quality}`);
  lines.push('');
  lines.push('=== INCLUDED FABRICS ===');
  if(included.length===0){ lines.push('(none)'); }
  included.forEach(x=>{
    lines.push(`- ${x.id}: file="${x.id+ext(x.file.name)}"`);
  });
  lines.push('');
  lines.push('=== EXCLUSIONS (NOT SENT) ===');
  if(excluded.length===0){ lines.push('(none)'); }
  excluded.forEach(x=> lines.push(`- ${x.id}: reason=${x.reason}`));
  lines.push('');
  lines.push('=== FILES IN THIS EXPORT ===');
  if(sofaBaseFile) lines.push(meta.files.base_image);
  included.forEach(x=> lines.push(x.id+ext(x.file.name)));

  return {meta, included, metaTxt: lines.join('\n'), quality};
}

/* ========================== Toast (UI affordance) ========================= */

function showToast(msg){
  const t=document.getElementById('toast'); if(!t) return;
  t.textContent=msg; t.classList.add('show');
  setTimeout(()=>t.classList.remove('show'), 1600);
}

/* ============================ Named Handlers ============================== */

// Hamburger: toggle menu
function handleHamburgerClick(){
  menu.classList.toggle('show');
}
// Close menu on outside click
function handleDocumentClick(e){
  if(!menu.contains(e.target) && e.target!==hambtn) menu.classList.remove('show');
}

// Stage nav
function handlePrevStepClick(){
  if(idx>0){ idx--; updateUI(); } else { gotoUpload(); }
}
function handleNextBtnClick(){
  if(idx<fabrics.length-1){ idx++; updateUI(); }
}

// Add a new fabric slot (up to 3). Starts empty (no image, no parts).
function handleAddBtnClick(){
  if(addBtn.disabled) return;
  // Start fresh: clear file inputs so the next pick always fires 'change'
  try{ const _f=document.getElementById('fabFile'); if(_f) _f.value=''; }catch(e){}
  try{ const _c=document.getElementById('fabCam');  if(_c) _c.value=''; }catch(e){}
  fabrics.push({id:fabrics.length, url:'', file: undefined});
  idx = fabrics.length-1;
  updateUI();
}



// Stage 1: selecting the base sofa image enables Continue after load
function handleSofaFileChange(e){
  const f=e.target.files?.[0]; if(!f) return;
  sofaChosen = true;
  sofaBaseFile = f;
  toFabricsBtn.disabled = false;
  sofaThumb.innerHTML = '<img>';
  loadImage(sofaThumb.firstElementChild, f);
  if(baseImg2){ loadImage(baseImg2, f); }
    if(fabrics.length===0) {
    fabrics.push({id:0, url:'', file: undefined});
  }
  idx = 0;

}
// Camera mirrors file selection
function handleSofaCamChange(){
  sofaFile.dispatchEvent(new Event('change'));
}
function handleToFabricsClick(){
  if(!sofaChosen) return;
  gotoFabrics();
}

// Fabric image selection for current fabric idx
function setFabricFromFile(file){
  // Revoke previous object URL (if any) to avoid leaks
  if (fabrics[idx]?.url) try{ URL.revokeObjectURL(fabrics[idx].url); }catch(e){}
  const url = URL.createObjectURL(file);
  fabrics[idx].url = url;
  fabrics[idx].file = file;
  fabImg.src = url;
  updateUI();
}

function handleFabFileChange(e){
  const f=e.target.files?.[0]; if(!f) return;
  setFabricFromFile(f);
  // Reset input so selecting the same file triggers 'change' in Chrome/Edge
  e.target.value = "";
}

function handleFabCamChange(e){
  const f=e.target.files?.[0]; if(!f) return;
  setFabricFromFile(f);
  // Reset input so selecting the same capture triggers 'change' in Chrome/Edge
  e.target.value = "";
}


// Quality toggle: (high/standard) 
function handleQToggleClick(e){
  const b = e.target.closest('button');
  if(!b) return;

  // Update UI active state
  [...qToggle.children].forEach(x=>x.classList.toggle('active',x===b));

  // Update global quality state 
  generationQuality = b.dataset.q;
}


// Part assignment rules (see original comments)
function handleSchemClick(e){
  const btn = e.target.closest('.part');
  if (!btn) return;
  const m = btn.dataset.mode;
  if (!m) return;
  // Only allow choosing the mode on the first fabric step
  if (idx !== 0) return;
  modeSelection = (m === 'single' ? 'single' : 'random');
  updateUI();
}


// Validation + ZIP build + download
async function handlePreviewClick(){
  const {errors, warnings} = validateBeforeGenerateSofa();
  if(errors.length>0){
    alert("Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ: " + errors.join(" "));
    return;
  }
  if(warnings.length>0){
    const proceed = confirm("Ù…ÙˆØ§Ø±Ø¯ Ø§Ø®ØªÛŒØ§Ø±ÛŒ (Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§ØµÙ„Ø§Ø­ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯): " + warnings.join(" ") + "\nØ§Ø¯Ø§Ù…Ù‡Ù” ØªÙˆÙ„ÛŒØ¯ØŸ");
    if(!proceed) return;
  }

  // -----------------------------------------------------------
  // If user selected random mode but fewer than 2 fabrics exist,
  // automatically switch to 'single' mode.
  // -----------------------------------------------------------
  // Auto-fix: Random mode requires at least 2 fabrics
  if (modeSelection === 'random' && fabrics.filter(f => !!f.url).length < 2) {
      modeSelection = 'single';
  }




  const {meta, included} = buildSofaMetaAndFiles();

  try {
    enterLoadingState();
    const imageBase64 = await sendToBackend(meta, included, sofaBaseFile);
    baseImg2.src = "data:image/png;base64," + imageBase64;
  } catch (err) {
    showToast("âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ±. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯.");
  } finally {
    exitLoadingState();
  }


  

}

// Remove current fabric (clears image + parts, reorders, selects next)
function handleRemoveFabricClick(){
  // Clear file inputs so re-selecting the same file triggers 'change'
  try{ const _f=document.getElementById('fabFile'); if(_f) _f.value=''; }catch(e){}
  try{ const _c=document.getElementById('fabCam');  if(_c) _c.value=''; }catch(e){}

  if(!fabrics[idx]) return;
  const removedIndex = idx;

  // Revoke object URL to free memory
  try{ if(fabrics[idx].url) URL.revokeObjectURL(fabrics[idx].url); }catch(e){}

  // Remove fabric slot
  fabrics.splice(idx,1);

  if(fabrics.length===0){
    fabrics.push({id:0,url:'', file: undefined});
    idx=0;
  }else{
    // Reindex ids
    fabrics.forEach((f,ii)=>{ f.id=ii; });
    // Select the next fabric after removed (or clamp)
    idx = Math.min(removedIndex, fabrics.length-1);
  }

  showToast("Ù¾Ø§Ø±Ú†Ù‡ Ø­Ø°Ù Ø´Ø¯.");
  updateUI();
}


// ====== NEW: Backend integration & loading state ======
async function sendToBackend(meta, included, baseFile) {
  const form = new FormData();
  form.append("meta", JSON.stringify(meta));
  if (baseFile) form.append("base_image", baseFile);

  for (const it of included) {
    form.append(it.id, it.file);
  }

  // to be removed in the production version
  console.log("Outgoing FormData:", [...form.entries()]);

  const res = await fetch("/api/generate", {
    method: "POST",
    body: form
  });

  if (!res.ok) throw new Error("Generation failed");
  const data = await res.json();
  return data.image_base64;
}

function enterLoadingState() {
  previewBtn.disabled = true;
  previewBtn.textContent = "â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯...";
  if (baseImg2) baseImg2.style.opacity = "0.4";
}

function exitLoadingState() {
  previewBtn.disabled = false;
  previewBtn.textContent = "âœ¨ Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´";
  if (baseImg2) baseImg2.style.opacity = "1";
}



/* ============================== Event Bindings ============================ */

// Hamburger + outside close
hambtn.addEventListener('click', handleHamburgerClick);
document.addEventListener('click', handleDocumentClick);

// Stage navigation
prevStep.addEventListener('click', handlePrevStepClick);
nextBtn.addEventListener('click', handleNextBtnClick);

// Add fabric
addBtn.addEventListener('click', handleAddBtnClick);

// Stage 1 (Upload)
sofaFile.addEventListener('change', handleSofaFileChange);
sofaCam .addEventListener('change', handleSofaCamChange);
toFabricsBtn.addEventListener('click', handleToFabricsClick);

// Stage 2 (Fabrics)
fabFile.addEventListener('change', handleFabFileChange);
fabCam .addEventListener('change', handleFabCamChange);
qToggle.addEventListener('click', handleQToggleClick);
schem  .addEventListener('click', handleSchemClick);

// Generate (Preview)
previewBtn.addEventListener('click', handlePreviewClick);

// Remove fabric (IIFE in original â†’ direct binding here)
(function bindRemoveFabric(){
  const btn=document.getElementById('removeFabBtn');
  if(!btn) return;
  btn.addEventListener('click', handleRemoveFabricClick);
})();

/* ================================== Init ================================= */

// Ensure we start with an empty fabric slot if needed
(function init(){
  if(fabrics.length===0){
    fabrics.push({id:0,url:'', file: undefined});
    idx=0;
  }
  // Do not call updateUI() here to avoid any visual flicker before user input.
})();

</script>

<div id="toast" role="status" aria-live="polite"></div>
</body>
</html>
