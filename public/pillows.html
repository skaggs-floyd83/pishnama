<!doctype html>
<!--
  Project: Pishnama â€” Sofa Fabric Assignment (Developer-Commented Copy)
  File: sofa_commented_dev.html
  Purpose:
    Two-stage flow to upload a sofa image and assign up to THREE fabrics to specific parts
    of the sofa (back/seat/arms). Uses pure HTML/CSS/vanilla JS. No network calls here.

  Key UX decisions (preserve behavior exactly):
    â€¢ Hamburger is icon-only (â˜°). Menu contains links to sofa & pillows pages.
    â€¢ File selection buttons are icon-only (ğŸ“ for choose file, ğŸ“· for camera).
    â€¢ Stages:
        1) Upload: user selects base sofa image; "Continue" becomes enabled after image loads.
        2) Fabrics: user iterates through per-fabric context and assigns fabric to parts.
    â€¢ Up to 3 fabrics are supported. The "Add Fabric" button:
        â€“ Shows â€œâ• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ {Ø¯ÙˆÙ…|Ø³ÙˆÙ…}â€ (dynamic ordinal)
        â€“ Is completely HIDDEN when three fabrics already exist (NOT disabled).
    â€¢ Placeholder text â€œÙ¾Ø§Ø±Ú†Ù‡ {Ø§ÙˆÙ„|Ø¯ÙˆÙ…|Ø³ÙˆÙ…} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯â€ appears inside the preview
      until the current fabric image is set.
    â€¢ â€œØ¨Ø®Ø´ Ù…Ø±Ø¨ÙˆØ·Ù‡â€ (part grid) controls assignment; a fabric can own any subset of parts.
      Visibility rules prevent conflicting assignments across fabrics.
    â€¢ â€œNextâ€ is always rendered (visible) but disabled when there is no next fabric.
    â€¢ â€œPreviewâ€ enables only when at least one part is selected for the current fabric.
  Notes for future devs:
    â€¢ Blob URLs (createObjectURL) are used for local previews; revoke on <img> load where applicable.
    â€¢ This page is self-contained UI only; model integration should be added where Preview is handled.
-->
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Ù¾ÛŒØ´Ù†Ù…Ø§ â€” Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</title>
<style>
  /* =========================
   Theme variables
   Default = dark
  ========================= */
  :root{
    --bg:#0b1020;
    --card:#0f162b;
    --muted:#94a3b8;
    --text:#e5e7eb;
    --border:#243045;
    --accent:#22c55e;
    --blue:#1f3a8a;
  }

  /* =========================
    Light mode overrides
  ========================= */
  html[data-theme="light"]{
    --bg:#f8fafc;
    --card:#ffffff;
    --muted:#475569;
    --text:#0f172a;
    --border:#e2e8f0;
    --accent:#16a34a;
    --blue:#2563eb;
  }

  html,body{margin:0;background:var(--bg);color:var(--text);font-family:Vazirmatn,IRANSans,Segoe UI,Roboto,Arial}
  .wrap{max-width:480px;margin:0 auto;min-height:100svh;/* replaced */ height:auto;/* added */display:flex;flex-direction:column}
  .bar{position:relative;padding:10px 14px;display:flex;justify-content:flex-start;align-items:center}
  /* Icon-only hamburger; text "Ù…Ù†Ùˆ" intentionally removed */
  .hamburger{border:1px solid var(--border);background:#0f1a33;color:#e2e8f0;border-radius:10px;padding:8px 12px;cursor:pointer}
  .menu{position:absolute;top:48px;right:14px;background:var(--card);border:1px solid var(--border);border-radius:12px;min-width:180px;display:none;flex-direction:column;overflow:hidden;z-index:10}
  .menu a{padding:10px 12px;color:#e5e7eb;text-decoration:none;border-bottom:1px solid var(--border);display:block}
  .menu a:last-child{border-bottom:0}
  .menu.show{display:flex}

  .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;margin:10px}
  .row{display:flex;align-items:center;gap:8px}
  .btn{border:1px solid var(--border);background:#0f1a33;color:#e2e8f0;border-radius:12px;padding:10px 14px;cursor:pointer}
  .btn.primary{background:var(--blue);border-color:var(--blue)}
  .btn:disabled{opacity:.5;cursor:not-allowed}

  /* Generic image frame for previews/placeholders */
  .thumb{position:relative;display:flex;align-items:center;justify-content:center;border:1px solid var(--border);border-radius:12px;min-height:120px;background:#0f172a;overflow:hidden}
  .thumb img{max-width:100%;max-height:100%;width:auto;height:auto;display:block}
  .badge{position:absolute;top:8px;right:8px;background:#0f1a33;border:1px solid var(--border);border-radius:999px;padding:4px 10px;font-size:.85rem;color:#e5e7eb}

  /* Quality toggle (two-state) */
  .toggle{display:inline-flex;border:1px solid var(--border);border-radius:999px;overflow:hidden}
  .toggle button{border:0;background:transparent;color:#cbd5e1;padding:8px 12px}
  .toggle .active{background:#193a88;color:#fff}

  /* Mode selection */
  .schem{
    display:flex;
    flex-direction:row;     
    gap:8px;
    margin-top:6px;
    justify-content:space-between;
    align-items:stretch;
  }
  .part{
    flex:1;
    min-height:56px;
    border:1px solid var(--border);
    border-radius:10px;
    background:#0f1a33;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:10px;
    text-align:center;
    line-height:1.4;
  }
  .part.active{
    background:#0e3a2b;
    border-color:#0e3a2b;
  }


  .viewport{flex:1;display:flex;flex-direction:column;gap:10px;overflow:auto/*replaced*/}
  .section{display:none;flex:1;overflow:auto/*replaced*/}
  .section.active{display:flex;flex-direction:column}

  .controls{margin:0 10px;display:flex;flex-direction:column;gap:10px;flex:1}
  .rightline{display:flex;justify-content:flex-start;align-items:center}
  .between{display:flex;justify-content:space-between;align-items:center}

  /* Fabric selection frame borrowed from pillows layout */
  .selectFrame{border:1px solid var(--border);border-radius:12px;padding:10px;background:#0f172a;display:flex;flex-direction:column;gap:10px;position:relative}

  /* Fixed heights used in mobile-safe viewport */
  #sofaThumb, #baseFrame { height: 220px !important; width: 100%; }
  #baseFrame img {
  margin-left: auto;
  margin-right: auto;
}

  #navRow{margin:0 10px;display:flex;justify-content:space-between;align-items:center}
  .tagsHeader{margin-top:14px;margin-bottom:6px;font-size:.95rem;color:var(--muted);}

  /* Tiny remove icon inside fabric frame */
  .tinyX{position:absolute;left:8px;top:8px;background:#0f1a33;border:1px solid var(--border);border-radius:8px;padding:4px 6px;cursor:pointer;font-size:14px;line-height:1}
  .tinyX:hover{background:#17213d}
  /* Toast */
  #toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#0f1a33;border:1px solid var(--border);color:#e5e7eb;padding:8px 12px;border-radius:10px;opacity:0;transition:opacity .25s;pointer-events:none;z-index:9999}
  #toast.show{opacity:1}

  .overlay{
    position:absolute;
    transform:translate(-50%,-50%);
    width:16px;
    height:16px;
    border-radius:4px;
    border:1px solid var(--accent);
    background-size:cover;
    background-position:center;

    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  .overlay.dragEnabled.dragActive {
    cursor: -webkit-grab;
    cursor: grab;
  }
  .overlay.dragEnabled.dragActive:active {
    cursor: -webkit-grabbing;
    cursor: grabbing;
  }



</style>
</head>
<body>
<div class="wrap">
  <!-- Header: hamburger only -->
  <div class="bar">
    <button class="hamburger" id="hambtn">â˜°</button>
    <button class="btn" id="loginBtn" style="margin-right:10px; direction: ltr;">ÙˆØ±ÙˆØ¯</button>
    <span id="credit-info" style="margin-right:10px;font-size:14px;"></span>
    <button class="btn" id="buyCreditsBtn" style="margin-right:10px; display:none;">
      ğŸ’³ Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±
    </button>
    <button class="btn" id="historyBtn" style="margin-right:10px; display:none;">
      ğŸ•˜ ØªØ§Ø±ÛŒØ®Ú†Ù‡
    </button>




    <div id="userMenu" 
     style="position:absolute; top:50px; right:10px; 
            background:#0f1629; border:1px solid #3a4367; 
            padding:10px; border-radius:8px; width:140px; 
            display:none; z-index:9999;">

      <button id="logoutBtn" 
              class="btn" 
              style="width:100%; background:#3a4367;">
          Ø®Ø±ÙˆØ¬
      </button>
    </div>



    <div class="menu" id="menu">
      <a href="sofa">ğŸ›‹ï¸ Ø·Ø±Ø§Ø­ÛŒ Ù…Ø¨Ù„</a>
      <a href="pillows">ğŸ›‹ï¸ Ø·Ø±Ø§Ø­ÛŒ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</a>
      <button
        id="themeToggleBtn"
        style="
          background:transparent;
          border:0;
          color:inherit;
          padding:10px 12px;
          text-align:right;
          cursor:pointer;
          font-family:inherit;
        ">
        ğŸŒ— ØªØºÛŒÛŒØ± Ø­Ø§Ù„Øª Ù†Ù…Ø§ÛŒØ´
      </button>

    </div>
  </div>

  <div class="viewport">
    <!-- ===== Stage 1: Upload base sofa image ===== -->
    <section id="step-upload" class="section active">
      <div class="card">
        <h3 style="margin:0 0 8px">ğŸ“· Ø¢Ù¾Ù„ÙˆØ¯ ØªØµÙˆÛŒØ± "Ù…Ø¨Ù„ Ùˆ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§"</h3>
        <div class="thumb" id="sofaThumb">
          <!-- <span class="hint">Ù‡Ù†ÙˆØ² ØªØµÙˆÛŒØ±ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡</span> -->
        </div>

        <div class="controls" style="margin-top: 8px;margin-right: 0px;margin-left: 0px;">
        <div class="row between">
          <!-- Icon-only file/camera per product decision -->
          <div class="row">
            <label class="btn" title="Ø§Ù†ØªØ®Ø§Ø¨ ÙØ§ÛŒÙ„">ğŸ“<input id="sofaFile" type="file" accept="image/*" hidden></label>
            <label class="btn" title="Ø¯ÙˆØ±Ø¨ÛŒÙ†">ğŸ“·<input id="sofaCam" type="file" accept="image/*" capture="environment" hidden></label>
          </div>
          <!-- Continue becomes enabled only after the image loads -->
          <button class="btn primary" id="toFabricsBtn" disabled>Ø§Ø¯Ø§Ù…Ù‡ â—€</button>
        </div>
      </div>

      </div>

    </section>

    <!-- ===== Stage 2: Fabric selection + part assignment ===== -->
    <section id="step-fabrics" class="section">
      <!-- Navigation row: â€œPrevâ€ always goes back to stage 1 if idx==0; â€œNextâ€ is visible but disabled if no next -->
      <div class="row" id="navRow">
        <button class="btn" id="prevStep">Ù‚Ø¨Ù„ÛŒ â–¶</button>
        <button class="btn" id="nextBtn">â—€ Ø¨Ø¹Ø¯ÛŒ</button>
      </div>

      <div class="card" id="frame">
        <!-- Stage 2 base sofa frame mirrors pillows layout -->
        <div class="thumb" id="baseFrame" style="margin-bottom: 15px;">          
          <img id="baseImg2" alt="">
        </div>
        <!-- Tagging controls (ONLY for tagged mode) -->
        <div class="row" id="tagControls" style="display:none; justify-content:flex-start; gap:8px; margin-bottom:8px;">
          <button class="btn" id="undoBtn" title="ÙˆØ§Ú¯Ø±Ø¯">â†©</button>
          <button class="btn" id="clearBtn" title="Ù¾Ø§Ú©â€ŒØ³Ø§Ø²ÛŒ">ğŸ—‘ï¸</button>
        </div>

        <div class="thumb" id="tagFrame" style="display:none; position:relative; margin-bottom:15px;">
          <img id="tagBaseImg" alt="">
        </div>

        <!-- Fabric selection frame with thumbnail + controls -->
        <div class="selectFrame">
          <button class="tinyX" id="removeFabBtn" title="Ø­Ø°Ù Ù¾Ø§Ø±Ú†Ù‡">ğŸ—‘ï¸</button>
          <!-- I commented this line and the related codes - I will probably delete it in the future (search wizBadge to find related codes) -->
          <!-- <span class="badge" id="wizBadge" style="display: none;">Ù¾Ø§Ø±Ú†Ù‡ 1 Ø§Ø² 1</span> -->
          <div class="row" style="justify-content:flex-start;width:100%">
            <strong id="selTitle" style="color:var(--muted);font-size:.95rem;">Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø§Ø±Ú†Ù‡ Ø§ÙˆÙ„</strong>
          </div>
          <div class="row" style="justify-content:space-between;width:100%">
            <div class="rightline" style="gap:8px">
              <label class="btn" title="Ø¢Ù¾Ù„ÙˆØ¯ Ù¾Ø§Ø±Ú†Ù‡">ğŸ“<input id="fabFile" type="file" accept="image/*" hidden></label>
              <label class="btn" title="Ø¯ÙˆØ±Ø¨ÛŒÙ†">ğŸ“·<input id="fabCam" type="file" accept="image/*" capture="environment" hidden></label>
            </div>
            <img id="fabImg" alt="" style="width:36px;height:36px;border-radius:8px;border:1px solid var(--border);object-fit:cover;background:#0f172a;visibility:hidden">
          </div>
          <!-- I commented this line and the related codes - I will probably delete it in the future (search fabPlaceholder to find related codes) -->
          <!-- <span id="fabPlaceholder" style="color:var(--muted);font-size:.9rem;display:block;">Ù¾Ø§Ø±Ú†Ù‡ Ø§ÙˆÙ„ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯</span> -->
          <div>
            <div class="tagsHeader" style="margin-top:0">Ø­Ø§Ù„Øª Ø§Ø¹Ù…Ø§Ù„ Ù¾Ø§Ø±Ú†Ù‡ Ø±ÙˆÛŒ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§</div>
            <div class="schem" id="schem">
              <button class="part" data-mode="single" style="color: #e2e8f0;">Ù‡Ù…Ù‡ Ø¨Ø§Ù„Ø´ØªÚ©â€ŒÙ‡Ø§ Ø¨Ø§ ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡</button>
              <button class="part" data-mode="tagged" style="color: #e2e8f0;">Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§Ù„Ø´ØªÚ©â€ŒÙ‡Ø§ Ùˆ Ù¾Ø§Ø±Ú†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù</button>
            </div>
          </div>
        </div>
        <!-- Add Fabric: HIDDEN when fabrics.length >= 3; otherwise enabled based on selection readiness -->
        <div class="controls">
          <div class="rightline" style="margin-top: 10px;">
            <button class="btn" id="addBtn">â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ Ø¯ÙˆÙ…</button>
          </div>
        </div>
      </div>

      

      <!-- Generate row: quality toggle + preview (integration point for the model) -->
      <div class="controls">
        <div class="rightline" style="gap:8px; margin-bottom: 20px; margin-top: 10px;">
          <div class="toggle" id="qToggle" style="margin-left: 10px;">
            <button class="active" data-q="high">Ù‡ÙˆØ´ ÛŒÚ© &nbsp; (2 Ø³Ú©Ù‡)</button>
            <button data-q="standard">Ù‡ÙˆØ´ Ø¯Ùˆ &nbsp; (1 Ø³Ú©Ù‡)</button>
          </div>
          <button class="btn primary" id="previewBtn">âœ¨ Ø¨Ø³Ø§Ø²</button>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
/* =============================================================================
   Pishnama â€” Sofa Page (Inline Script, Refactored)
   Scope: Internal modularization & comments ONLY â€” ZERO behavior/UI changes
   Notes:
     - Public IDs/classes and Persian text are untouched.
     - Structure: Typedefs â†’ Constants/DOM â†’ State â†’ Helpers â†’ Core UI Sync
                  â†’ Validation/Export â†’ Handlers â†’ Event Bindings â†’ Init
============================================================================= */

/** ============================================================================
 * Typedefs (documentation only)
 * @typedef {{ id:number, url:string, file?:File }} Fabric
 * ========================================================================== */

/* ============================== Constants / DOM ============================ */

function displayPhone(identifier) {
    // Convert +989123456789 â†’ 09123456789
    if (identifier.startsWith("+98") && identifier.length === 13) {
        return "0" + identifier.slice(3);
    }
    return identifier; // email or unexpected case
}

function updateLoginButton() {

    // Hard reset auth-dependent UI
    document.getElementById("credit-info").textContent = "";

    const buyCreditsBtn = document.getElementById("buyCreditsBtn");
    const historyBtn = document.getElementById("historyBtn");
    const userMenu = document.getElementById("userMenu");
    const creditInfo = document.getElementById("credit-info");

    if (buyCreditsBtn) buyCreditsBtn.style.display = "none";
    if (historyBtn) historyBtn.style.display = "none";
    if (userMenu) userMenu.style.display = "none";
    if (creditInfo) creditInfo.textContent = "";
    // NEW: hide credit-info completely when logged out (expiry is inside this text)
    if (creditInfo) creditInfo.style.display = "none";



    const btn = document.getElementById("loginBtn");
    if (!btn) return;

    const token = localStorage.getItem("pishnama_user_token");
    const identifier = localStorage.getItem("pishnama_user_identifier");
    

    if (token) {
      if (creditInfo) creditInfo.style.display = "inline";
      if (buyCreditsBtn) buyCreditsBtn.style.display = "inline-block";
      if (historyBtn) historyBtn.style.display = "inline-block";
    } else {
      if (creditInfo) { creditInfo.textContent = ""; creditInfo.style.display = "none"; }
      if (buyCreditsBtn) buyCreditsBtn.style.display = "none";
      if (historyBtn) historyBtn.style.display = "none";
    }



    if (token) {
        // User is logged in
        btn.textContent = displayPhone(identifier);
        btn.disabled = false;      // optional: prevent modal opening
        btn.style.opacity = "0.8";
    } else {
        // User is not logged in
        btn.textContent = "ÙˆØ±ÙˆØ¯";
        btn.disabled = false;
        btn.style.opacity = "1";
        userMenu.style.display = "none";
    }



    if (!token && creditInfo) {
        creditInfo.textContent = "";
    }



}

function forceLogoutIfInvalid(tokenResponse, authOptions = {}) {
    if (tokenResponse && tokenResponse.error === "login_required") {
        // Clear credentials
        localStorage.removeItem("pishnama_user_token");
        localStorage.removeItem("pishnama_user_identifier");

        // If this is an automatic logout (page load / background fetch),
        // do a hard refresh to guarantee a clean UI state.
        if (authOptions.silent) {
            window.location.reload();
            return true;
        }

        // User-visible logout (no refresh)
        updateLoginButton();
        showToast("Ù†Ø´Ø³Øª Ú©Ø§Ø±Ø¨Ø±ÛŒ Ø´Ù…Ø§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.");
        return true;
    }
    return false;
}


async function fetchWithAuth(url, options = {}) {
  const token = localStorage.getItem("pishnama_user_token");

  const res = await fetch(url, {
    ...options,
    headers: {
      ...(options.headers || {}),
      "x-user-token": token || ""
    }
  });

  let data = null;
  try {
    data = await res.json();
  } catch (_) {}

  // Centralized auth invalidation
  if (res.status === 401 || data?.error === "login_required") {
    forceLogoutIfInvalid(data, options?.auth || {});
    throw new Error("Unauthorized");
  }

  return { res, data };
}


// Maps 1..3 to Persian ordinals: Ø§ÙˆÙ„ / Ø¯ÙˆÙ… / Ø³ÙˆÙ…
function faOrdinal(n){ return n===1?'Ø§ÙˆÙ„':(n===2?'Ø¯ÙˆÙ…':'Ø³ÙˆÙ…'); }

// Hamburger
const hambtn   = document.getElementById('hambtn');
const menu     = document.getElementById('menu');

// Stage 1 (Upload)
const sofaFile     = document.getElementById('sofaFile');
const sofaCam      = document.getElementById('sofaCam');
const sofaThumb    = document.getElementById('sofaThumb');
const toFabricsBtn = document.getElementById('toFabricsBtn');
const stepUpload   = document.getElementById('step-upload');

// Stage 2 (Fabrics)
const stepFabrics  = document.getElementById('step-fabrics');
const baseImg2     = document.getElementById('baseImg2');
const fabFile      = document.getElementById('fabFile');
const fabCam       = document.getElementById('fabCam');
const fabImg       = document.getElementById('fabImg');
const selTitle     = document.getElementById('selTitle');
// const wizBadge     = document.getElementById('wizBadge');
const qToggle      = document.getElementById('qToggle');
const schem        = document.getElementById('schem');
const previewBtn   = document.getElementById('previewBtn');
const addBtn       = document.getElementById('addBtn');
const nextBtn      = document.getElementById('nextBtn');
const prevStep     = document.getElementById('prevStep');

const tagFrame = document.getElementById('tagFrame');
const tagControls = document.getElementById('tagControls');
const tagBaseImg = document.getElementById('tagBaseImg');
const undoBtn = document.getElementById('undoBtn');
const clearBtn = document.getElementById('clearBtn');




/* ================================== State ================================= */

// Global UI state (no persistence)
let pillowsChosen   = false; // becomes true after an image is picked
/** @type {Fabric[]} */
let fabrics      = [];    // each item: { id, url, file?:File }
let idx          = 0;     // index of "current" fabric being edited
let pillowsBaseFile = null;  // keep original base sofa File for export
let draggingTag = null; // { el, pointerId }


// NEW: Global quality setting (standard | high)
let generationQuality = "high";

// pillows mode selection:
// - "single": one fabric for all pillows
// - "tagged": per-pillow explicit assignment (future rounds)
let modeSelection = "single";   // default selection



let historyPage = 1;
let historyTotal = 0;
const HISTORY_PAGE_SIZE = 12;


/* =============================== Helpers ================================== */

async function refreshCredits() {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) return;

  let data;
  try {
    ({ data } = await fetchWithAuth("/api/credits", {
      auth: { silent: true }
    }));
  } catch {
    return;
  }


  const el = document.getElementById("credit-info");
  if (!el) return;

  if (data.credits_expires_at) {
    el.textContent = `Ø§Ø¹ØªØ¨Ø§Ø±: ${data.credits} (ØªØ§ ${new Date(data.credits_expires_at).toLocaleDateString("fa-IR")})`;
  } else {
    el.textContent = `Ø§Ø¹ØªØ¨Ø§Ø±: ${data.credits}`;
  }
  el.style.display = "inline";
}


/** Set <img>.src with a Blob URL; revoke URL after load to avoid leaks */
function loadImage(el, file){
  const url = URL.createObjectURL(file);
  el.src = url;
  el.onload = () => URL.revokeObjectURL(url);
}

// Fetch & render history
async function loadHistory(reset = false) {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) return;

  if (reset) {
    historyPage = 1;
    document.getElementById("historyGrid").innerHTML = "";
  }

  let data;
  try {
    ({ data } = await fetchWithAuth(
      `/api/history?page=${historyPage}&pageSize=${HISTORY_PAGE_SIZE}`
    ));
  } catch {
    return;
  }



  historyTotal = data.total;

  for (const item of data.items) {
    const div = document.createElement("div");
    div.style.border = "1px solid #3a4367";
    div.style.borderRadius = "8px";
    div.style.padding = "6px";
    div.style.fontSize = "12px";

    div.innerHTML = `
      <img src="${item.output_image_url}"
           data-creation-id="${item.id}"
           class="history-thumb"
           style="width:100%; border-radius:6px; display:block; cursor:pointer;">
      <div style="margin-top:6px;">
        <div>Ù†ÙˆØ¹: ${item.mode}</div>
        <div>Ú©ÛŒÙÛŒØª: ${item.quality}</div>
        <div>Ù‡Ø²ÛŒÙ†Ù‡: ${item.cost_credits}</div>
        <div>${new Date(item.created_at).toLocaleDateString("fa-IR")}</div>
      </div>
    `;

    document.getElementById("historyGrid").appendChild(div);
  }

  historyPage++;

  const shown = document.getElementById("historyGrid").children.length;
  document.getElementById("historyLoadMoreBtn").style.display =
    shown < historyTotal ? "inline-block" : "none";
}





// ======================= IMAGE COMPRESSION HELPERS =========================

const MAX_BASE_BYTES   = 3 * 1024 * 1024;  // 3 MB threshold for sofa+pillows base image
const MAX_FABRIC_BYTES = 3 * 1024 * 1024;  // 3 MB threshold for fabrics
const BASE_MAX_SIDE    = 1536;
const FABRIC_MAX_SIDE  = 1024;

function ensureJpegName(name) {
  if (!name) return "image.jpg";
  return name.replace(/\.[^.]+$/,"") + ".jpg";
}

function loadFileToImage(file) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      URL.revokeObjectURL(url);
      resolve(img);
    };
    img.onerror = (err) => {
      URL.revokeObjectURL(url);
      reject(err);
    };
    img.src = url;
  });
}

function loadUrlToImage(url) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}


async function compressImageIfNeeded(file, { maxBytes, maxSide }) {
  if (file.type === "image/jpeg" && file.size <= maxBytes) {
    return file;
  }

  const img = await loadFileToImage(file);
  const longest = Math.max(img.width || maxSide, img.height || maxSide);
  const scale   = longest > maxSide ? (maxSide / longest) : 1;

  const targetW = Math.max(1, Math.round((img.width  || maxSide) * scale));
  const targetH = Math.max(1, Math.round((img.height || maxSide) * scale));

  const canvas = document.createElement("canvas");
  canvas.width  = targetW;
  canvas.height = targetH;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, targetW, targetH);

  let quality = 0.85;
  let lastBlob = null;

  for (let i = 0; i < 4; i++) {
    const blob = await new Promise(resolve =>
      canvas.toBlob(resolve, "image/jpeg", quality)
    );
    if (!blob) break;
    lastBlob = blob;

    if (blob.size <= maxBytes || quality <= 0.6) {
      return new File([blob], ensureJpegName(file.name), { type: "image/jpeg" });
    }
    quality -= 0.1;
  }

  if (lastBlob) {
    return new File([lastBlob], ensureJpegName(file.name), { type: "image/jpeg" });
  }
  return file;
}



/** Stage navigation (no side effects beyond DOM visibility) */
function gotoUpload(){
  stepFabrics.classList.remove('active');
  stepUpload.classList.add('active');

  // ğŸ”§ FIX: restore base image preview when navigating back
  if (pillowsBaseFile && sofaThumb) {
    sofaThumb.innerHTML = '<img>';
    loadImage(sofaThumb.firstElementChild, pillowsBaseFile);

    // allow going forward again after restore
    toFabricsBtn.disabled = false;
  }
}

function gotoFabrics(){
  stepUpload.classList.remove('active');
  stepFabrics.classList.add('active');
  updateUI();
}

/* ============================== Core UI Sync ============================== */
/*
  Responsibilities:
    1) Update preview image + placeholder text
    2) Update part grid visibility/active states under conflicting assignments
    3) Manage â€œAdd Fabricâ€ (show/hide + label + enabled state)
    4) Keep â€œNextâ€ visible but disabled when there is no next fabric
    5) Enable Preview (generate) â€” validation happens on click
*/
function updateUI(){
  if(!fabrics[idx]) return;
  const cur = fabrics[idx];

  // 1) Preview (image or ordinal placeholder)
  fabImg.src = cur.url || '';
  fabImg.style.visibility = cur.url ? 'visible' : 'hidden';
  // const ph = document.getElementById('fabPlaceholder');
  // if(cur.url){ ph.style.display='none'; }
  // else { ph.textContent = `Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(idx+1)} Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯`; ph.style.display='block'; }
  if(selTitle){ selTitle.textContent = `Ø§Ù†ØªØ®Ø§Ø¨ Ù¾Ø§Ø±Ú†Ù‡ ${faOrdinal(idx+1)}`; }

  // Wizard badge: "Ù¾Ø§Ø±Ú†Ù‡ X Ø§Ø² N"
  // wizBadge.textContent = `Ù¾Ø§Ø±Ú†Ù‡ ${idx+1} Ø§Ø² ${fabrics.length}`;


  // Hide or show the mode title based on stage
  const modeTitle = document.querySelector('.tagsHeader');
  if (modeTitle) {
      modeTitle.style.display = (idx === 0 ? 'block' : 'none');
  }

  // 2) Mode buttons visibility & active state
  if (schem) {
    schem.querySelectorAll('.part').forEach(btn => {
      if (idx === 0) {
        btn.style.display = 'block';
        const m = btn.dataset.mode;
        btn.classList.toggle('active', modeSelection === m);
      } else {
        // On fabric #2 and #3, hide the mode buttons completely
        btn.style.display = 'none';
      }
    });
  }
  
  
  // 
  const baseFrame = document.getElementById('baseFrame');
  if (modeSelection === "tagged") {
    baseFrame.style.display = "none";
    if (tagFrame) tagFrame.style.display = "block";
    if (tagControls) tagControls.style.display = "flex";
  } else {
    baseFrame.style.display = "block";
    if (tagFrame) tagFrame.style.display = "none";
    if (tagControls) tagControls.style.display = "none";
  }



  // 3) Generate is always enabled; validation happens on click now
  previewBtn.disabled = false;

  // 4) Add Fabric management (depends on mode)
  const multiAllowed = (modeSelection === 'tagged');
  if (!multiAllowed) {
    // In single mode (or before choosing a mode), hide the Add button
    addBtn.style.display = 'none';
  } else {
    if (fabrics.length >= 3) {
      addBtn.style.display = 'none';
    } else {
      addBtn.style.display = 'inline-block';
      const nextOrdinal = faOrdinal(Math.min(fabrics.length+1,3));
      addBtn.textContent = `â• Ø§ÙØ²ÙˆØ¯Ù† Ù¾Ø§Ø±Ú†Ù‡ ${nextOrdinal}`;

      // a fabric and at least one tag is needed
      const currentReady = !!cur.url && Array.isArray(cur.tags) && cur.tags.length > 0;
      addBtn.disabled = !currentReady;
    }
  }

  // 5) Next button: always present; disabled if there is no next fabric
  nextBtn.style.display='inline-block';
  
  // Can move to next fabric only if:
  // 1) there IS a next fabric
  // 2) current fabric is semantically ready
  let canAdvance = false;

  if (idx < fabrics.length - 1) {
    if (modeSelection === "single") {
      canAdvance = !!cur.url;
    } else {
      canAdvance =
        !!cur.url &&
        Array.isArray(cur.tags) &&
        cur.tags.length > 0;
    }
  }

  nextBtn.disabled = !canAdvance;


  updateOverlayCursor();

}


// tagging interaction
function handleTagFrameClick(e){
  if (modeSelection !== "tagged") return;
  if (!fabrics[idx] || !fabrics[idx].url) return;

  const frame = document.getElementById("tagFrame");
  const rect = frame.getBoundingClientRect();

  const x = (e.clientX - rect.left) / rect.width;
  const y = (e.clientY - rect.top) / rect.height;

  const tag = { id: Date.now(), x, y };
  fabrics[idx].tags.push(tag);

  renderTags();
  updateUI();
} 

function updateOverlayCursor(){
  const nodes = tagFrame.querySelectorAll(".overlay");
  nodes.forEach(d => {
    const own = Number(d.dataset.owner);
    if (own === idx && d.classList.contains("dragEnabled")) {
      d.classList.add("dragActive");
    } else {
      d.classList.remove("dragActive");
    }
  });
}


function renderTags(){
  const frame = document.getElementById("tagFrame");
  if (!frame) return;

  frame.querySelectorAll(".overlay").forEach(n => n.remove());

  fabrics.forEach((f, fi) => {
    if (!f.tags || !f.url) return;

    f.tags.forEach((t, ti) => {
      const d = document.createElement("div");
      d.className = "overlay";
      d.style.left = (t.x * 100) + "%";
      d.style.top  = (t.y * 100) + "%";
      d.style.backgroundImage = `url(${f.url})`;
      d.dataset.owner = fi;
      d.dataset.ti = ti;
      d.style.touchAction = "none";
      d.addEventListener("contextmenu", e => e.preventDefault());


      // ===== DRAG START =====
      d.addEventListener("pointerdown", (ev) => {
        if (Number(d.dataset.owner) !== idx) return;
        ev.stopPropagation();
        d.setPointerCapture(ev.pointerId);
        draggingTag = { el: d, pointerId: ev.pointerId };
      });

      // ===== DRAG MOVE =====
      d.addEventListener("pointermove", (ev) => {
        if (!draggingTag || draggingTag.el !== d) return;

        const r = frame.getBoundingClientRect();
        let nx = (ev.clientX - r.left) / r.width;
        let ny = (ev.clientY - r.top)  / r.height;

        nx = Math.max(0, Math.min(1, nx));
        ny = Math.max(0, Math.min(1, ny));

        d.style.left = (nx * 100) + "%";
        d.style.top  = (ny * 100) + "%";

        const owner = Number(d.dataset.owner);
        const ti = Number(d.dataset.ti);
        if (fabrics[owner] && fabrics[owner].tags[ti]) {
          fabrics[owner].tags[ti].x = nx;
          fabrics[owner].tags[ti].y = ny;
        }
      });

      // ===== DRAG END =====
      d.addEventListener("pointerup", (ev) => {
        if (!draggingTag || draggingTag.el !== d) return;
        d.releasePointerCapture(ev.pointerId);
        draggingTag = null;
      });
      // Enable grab cursor only after the user actually moves the pointer
      (function(){
        let startX = null, startY = null;
        const enableAfterMove = (ev) => {
          if (startX === null) {
            startX = ev.clientX;
            startY = ev.clientY;
            return;
          }
          if (Math.abs(ev.clientX - startX) > 5 || Math.abs(ev.clientY - startY) > 5) {
            d.classList.add("dragEnabled");
            if (Number(d.dataset.owner) === idx) {
              d.classList.add("dragActive");
            }
            document.removeEventListener("pointermove", enableAfterMove);
          }
        };
        document.addEventListener("pointermove", enableAfterMove);
      })();



      // Prevent click-through
      d.addEventListener("click", ev => ev.stopPropagation());

      frame.appendChild(d);
    });
  });

  updateOverlayCursor();
}




async function makeAnnotatedBaseImageBlob() {
  if (!baseImg2 || !pillowsBaseFile) return null;

  const img = await loadFileToImage(pillowsBaseFile);

  const canvas = document.createElement("canvas");
  canvas.width = img.naturalWidth || img.width;
  canvas.height = img.naturalHeight || img.height;

  const ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

  const frameRect = tagFrame.getBoundingClientRect();
  const sx = canvas.width / frameRect.width;
  const sy = canvas.height / frameRect.height;

  // Build a cache
  const fabricImgCache = new Map();
  for (const f of fabrics) {
    if (f.url) {
      try {
        fabricImgCache.set(f.url, await loadUrlToImage(f.url));
      } catch {}
    }
  }


  
  // draw each tag as a colored + named marker (F1/F2/F3), like server_____2.js
  const COLORS = { F1: "#ff3b30", F2: "#34c759", F3: "#0a84ff" };

  fabrics.forEach((f, fi) => {
    if (!f.tags || !f.tags.length) return;

    const label = `F${fi + 1}`;
    const fill = COLORS[label] || "#ffffff";

    f.tags.forEach(t => {
      const cx = t.x * frameRect.width * sx;
      const cy = t.y * frameRect.height * sy;

      // Radius scaled similarly to the demo (but in your canvas coordinate system)
      const r = Math.max(10, canvas.width * 0.018);

      // Filled circle
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.globalAlpha = 0.92;
      ctx.fill();
      ctx.globalAlpha = 1;

      // Subtle border
      ctx.lineWidth = Math.max(2, canvas.width * 0.002);
      ctx.strokeStyle = "rgba(0,0,0,.25)";
      ctx.stroke();

      // White label text (F1/F2/F3)
      ctx.fillStyle = "#fff";
      ctx.font = `${Math.floor(r * 0.9)}px sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(label, cx, cy);

      ctx.restore();
    });
  });






  return await new Promise(res =>
    canvas.toBlob(res, "image/png", 0.92)
  );
}


// handlers
function handleUndoTag(){
  if (!fabrics[idx] || fabrics[idx].tags.length === 0) return;
  fabrics[idx].tags.pop();
  renderTags();
}
function handleClearTags(){
  if (!fabrics[idx]) return;
  fabrics[idx].tags = [];
  renderTags();
}



/* ===================== Validation (pre-generation) ======================== */

function validateBeforeGenerateSofa(){
  const errors = [];
  const warnings = [];

  // Base image is required
  if(!pillowsChosen){
    errors.push("\n- ØªØµÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡Ù” Ù…Ø¨Ù„ Ùˆ Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª.");
  }

  const fabricsWithImg = fabrics.filter(f => !!f.url);

  if(fabricsWithImg.length === 0){
    errors.push("\n- Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© ØªØµÙˆÛŒØ± Ù¾Ø§Ø±Ú†Ù‡ Ø¨Ø§ÛŒØ¯ Ø¢Ù¾Ù„ÙˆØ¯ Ø´ÙˆØ¯.");
  }

  if(!modeSelection){
    errors.push("\n- Ø¨Ø§ÛŒØ¯ ÛŒÚ©ÛŒ Ø§Ø² Ø¯Ùˆ Ø­Ø§Ù„Øª Â«Ù‡Ù…Ù‡ Ø¨Ø§Ù„Ø´ØªÚ©â€ŒÙ‡Ø§ Ø¨Ø§ ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡Â» ÛŒØ§ Â«Ø§Ù†ØªØ®Ø§Ø¨ Ø¨Ø§Ù„Ø´ØªÚ©â€ŒÙ‡Ø§ Ùˆ Ù¾Ø§Ø±Ú†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„ÙÂ» Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.");
  }

  if(modeSelection === 'single' && fabricsWithImg.length > 1){
    warnings.push("\n- Ø¯Ø± Ø­Ø§Ù„Øª Â«Ù‡Ù…Ù‡Ù” Ø¨Ø§Ù„Ø´ØªÚ© Ù‡Ø§ Ø¨Ø§ ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡Â» ÙÙ‚Ø· Ù¾Ø§Ø±Ú†Ù‡Ù” Ø§ÙˆÙ„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Ø¨Ù‚ÛŒÙ‡ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ú¯Ø±ÙØªÙ‡ Ø®ÙˆØ§Ù‡Ù†Ø¯ Ø´Ø¯.");
  }
  
  if (modeSelection === "tagged") {
    const valid = fabrics.some(f => f.file && f.tags && f.tags.length > 0);
    if (!valid) {
      errors.push("\n- Ø¨Ø§ÛŒØ¯ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ù¾Ø§Ø±Ú†Ù‡ Ùˆ Ø­Ø¯Ø§Ù‚Ù„ ÛŒÚ© Ø¨Ø§Ù„Ø´ØªÚ© Ø§Ù†ØªØ®Ø§Ø¨â€Œ Ø´Ø¯Ù‡ Ø¨Ø§Ø´Ø¯.");
    }
  }




  return {errors, warnings};
}


/* ========================== Toast (UI affordance) ========================= */

function showToast(msg){
  const t=document.getElementById('toast'); if(!t) return;
  t.textContent=msg; t.classList.add('show');
  setTimeout(()=>t.classList.remove('show'), 1600);
}

/* ============================ Named Handlers ============================== */

// Hamburger: toggle menu
function handleHamburgerClick(){
  menu.classList.toggle('show');
}
// Close menu on outside click
function handleDocumentClick(e){
  if(!menu.contains(e.target) && e.target!==hambtn) menu.classList.remove('show');
}

// Stage nav
function handlePrevStepClick(){
  if(idx>0){ idx--; updateUI(); } else { gotoUpload(); }
}
function handleNextBtnClick(){
  if(idx<fabrics.length-1){ idx++; updateUI(); }
}

// Add a new fabric slot (up to 3). Starts empty (no image, no parts).
function handleAddBtnClick(){
  if(addBtn.disabled) return;
  // Start fresh: clear file inputs so the next pick always fires 'change'
  try{ const _f=document.getElementById('fabFile'); if(_f) _f.value=''; }catch(e){}
  try{ const _c=document.getElementById('fabCam');  if(_c) _c.value=''; }catch(e){}
  fabrics.push({id:fabrics.length, url:'', file: undefined, tags: []});
  idx = fabrics.length-1;
  updateUI();
}



// Stage 1: selecting the base sofa image enables Continue after load
async function handleSofaFileChange(e){
  const originalFile = e.target.files?.[0];
  if (!originalFile) return;

  const file = await compressImageIfNeeded(originalFile, {
    maxBytes: MAX_BASE_BYTES,
    maxSide: BASE_MAX_SIDE
  });

  pillowsChosen   = true;
  pillowsBaseFile = file;

  toFabricsBtn.disabled = false;
  sofaThumb.innerHTML = '<img>';
  loadImage(sofaThumb.firstElementChild, file);
  if (baseImg2) {
    loadImage(baseImg2, file);
  }

  if (fabrics.length === 0) {
    fabrics.push({ id: 0, url: "", file: undefined, tags: [] });
  }
  idx = 0;
}


// Camera mirrors file selection
function handleSofaCamChange(){
  sofaFile.dispatchEvent(new Event('change'));
}
function handleToFabricsClick(){
  if(!pillowsChosen) return;
  gotoFabrics();
}

// Fabric image selection for current fabric idx
async function setFabricFromFile(file){
  const processed = await compressImageIfNeeded(file, {
    maxBytes: MAX_FABRIC_BYTES,
    maxSide: FABRIC_MAX_SIDE
  });

  // Revoke previous object URL (if any) to avoid leaks
  if (fabrics[idx]?.url) {
    try { URL.revokeObjectURL(fabrics[idx].url); } catch (e) {}
  }

  const url = URL.createObjectURL(processed);
  fabrics[idx].url  = url;
  fabrics[idx].file = processed;
  fabImg.src = url;
  renderTags();
  updateUI();
}



async function handleFabFileChange(e){
  const f = e.target.files?.[0];
  if (!f) return;
  await setFabricFromFile(f);
  // Reset input so selecting the same file triggers 'change' in Chrome/Edge
  e.target.value = "";
}

async function handleFabCamChange(e){
  const f = e.target.files?.[0];
  if (!f) return;
  await setFabricFromFile(f);
  // Reset input so selecting the same capture triggers 'change' in Chrome/Edge
  e.target.value = "";
}




// Quality toggle: (high/standard) 
function handleQToggleClick(e){
  const b = e.target.closest('button');
  if(!b) return;

  // Update UI active state
  [...qToggle.children].forEach(x=>x.classList.toggle('active',x===b));

  // Update global quality state 
  generationQuality = b.dataset.q;
}


// Part assignment rules (see original comments)
function handleSchemClick(e){
  const btn = e.target.closest('.part');
  if (!btn) return;

  const m = btn.dataset.mode;
  if (!m) return;

  // Mode selection is allowed only on the first fabric
  if (idx !== 0) return;

  if (m === "single") {
    modeSelection = "single";
  } else if (m === "tagged") {
    // Entering tagged mode (one-time setup)
    if (modeSelection !== "tagged") {
      modeSelection = "tagged";

      if (tagBaseImg && pillowsBaseFile) {
        const u = URL.createObjectURL(pillowsBaseFile);
        tagBaseImg.src = u;
        tagBaseImg.onload = () => { try { URL.revokeObjectURL(u); } catch(e){} };
      }
    }
  }


  updateUI();
}



// Validation + ZIP build + download
async function handlePreviewClick(){

  // ========== REQUIRE LOGIN ==========
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) {
      alert("Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ø§Ù…Ù‡ØŒ Ù„Ø·ÙØ§Ù‹ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.");
      loginModal.style.display = "flex";   // show the login modal automatically
      return;
  }

  // Compute required cost on client
  const cost = (generationQuality === "high") ? 2 : 1;
  // Call credits endpoint BEFORE validation & uploads
  let creditData;
  try {
    ({ data: creditData } = await fetchWithAuth("/api/credits"));
  } catch {
    return; // login_required already handled
  }

  if (creditData.credits < cost) {
    alert(
      `Ø§Ø¹ØªØ¨Ø§Ø± Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª.\n` +
      `Ù…ÙˆØ¬ÙˆØ¯ÛŒ: ${creditData.credits}\n` +
      `Ù†ÛŒØ§Ø²: ${cost}`
    );
    return;
  }



  const {errors, warnings} = validateBeforeGenerateSofa();
  if(errors.length>0){
    alert("Ø®Ø·Ø§Ù‡Ø§ÛŒ Ø¶Ø±ÙˆØ±ÛŒ: " + errors.join(" "));
    return;
  }
  if(warnings.length>0){
    const proceed = confirm("Ù…ÙˆØ§Ø±Ø¯ Ø§Ø®ØªÛŒØ§Ø±ÛŒ (Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§ØµÙ„Ø§Ø­ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ø§Ø¯Ø§Ù…Ù‡ Ø¯Ù‡ÛŒØ¯): " + warnings.join(" ") + "\nØ§Ø¯Ø§Ù…Ù‡Ù” ØªÙˆÙ„ÛŒØ¯ØŸ");
    if(!proceed) return;
  }


  ////
  let meta;
  let included = [];

  if (modeSelection === "single") {
    // EXISTING BEHAVIOR â€” unchanged
    meta = {
      mode: "pillows",
      mode_selection: "single",
      quality: generationQuality,
      fabrics: [{ id: "fabric_01" }]
    };

    included = fabrics
      .filter(f => !!f.file)
      .slice(0, 1)
      .map((f, i) => ({
        id: `fabric_${String(i + 1).padStart(2, "0")}`,
        file: f.file
      }));

    try {
      enterLoadingState();
      const imageBase64 = await sendToBackend(meta, included, pillowsBaseFile);
      if (!imageBase64) return;
      baseImg2.src = "data:image/png;base64," + imageBase64;
      refreshCredits();
    } finally {
      exitLoadingState();
    }

  } else if (modeSelection === "tagged") {
    // NEW BEHAVIOR â€” annotated base image only
    const annotatedBlob = await makeAnnotatedBaseImageBlob();
    if (!annotatedBlob) {
      alert("Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ù†Ø´Ø§Ù†Ù‡â€ŒÚ¯Ø°Ø§Ø±ÛŒâ€ŒØ´Ø¯Ù‡.");
      return;
    }

    meta = {
      mode: "pillows",
      mode_selection: "tagged",
      quality: generationQuality,
      fabrics: fabrics
        .filter(f => f.file && f.tags && f.tags.length > 0)
        .map((f, i) => ({
          id: `fabric_${String(i + 1).padStart(2, "0")}`,
          tag_count: f.tags.length
        }))
    };

    included = fabrics
      .filter(f => f.file && f.tags && f.tags.length > 0)
      .map((f, i) => ({
        id: `fabric_${String(i + 1).padStart(2, "0")}`,
        file: f.file
      }));

    const annotatedFile = new File(
      [annotatedBlob],
      "base_image_annotated.png",
      { type: "image/png" }
    );

    try {
      enterLoadingState();

      //temporary
      // window.open(URL.createObjectURL(annotatedBlob));

      const imageBase64 = await sendToBackend(meta, included, annotatedFile);
      if (!imageBase64) return;
      baseImg2.src = "data:image/png;base64," + imageBase64;
      refreshCredits();
    } finally {
      exitLoadingState();
    }
  }
  ////


  

}

// Remove current fabric (clears image + parts, reorders, selects next)
function handleRemoveFabricClick(){
  // Clear file inputs so re-selecting the same file triggers 'change'
  try{ const _f=document.getElementById('fabFile'); if(_f) _f.value=''; }catch(e){}
  try{ const _c=document.getElementById('fabCam');  if(_c) _c.value=''; }catch(e){}

  if(!fabrics[idx]) return;
  const removedIndex = idx;

  // Revoke object URL to free memory
  try{ if(fabrics[idx].url) URL.revokeObjectURL(fabrics[idx].url); }catch(e){}

  // Remove fabric slot
  fabrics.splice(idx,1);

  if(fabrics.length===0){
    fabrics.push({ id: 0, url: "", file: undefined, tags: [] });
    idx=0;
  }else{
    // Reindex ids
    fabrics.forEach((f,ii)=>{ f.id=ii; });
    // Select the next fabric after removed (or clamp)
    idx = Math.min(removedIndex, fabrics.length-1);
  }

  showToast("Ù¾Ø§Ø±Ú†Ù‡ Ø­Ø°Ù Ø´Ø¯.");
  renderTags();
  updateUI();
}


// ====== NEW: Backend integration & loading state ======
async function sendToBackend(meta, included, baseFile) {
  const form = new FormData();
  form.append("meta", JSON.stringify(meta));
  if (baseFile) form.append("base_image", baseFile);

  for (const it of included) {
    form.append(it.id, it.file);
  }

  // to be removed in the production version
  console.log("Outgoing FormData:", [...form.entries()]);

  let data;
  try {
    ({ data } = await fetchWithAuth("/api/generate", {
      method: "POST",
      body: form
    }));
  } catch {
    throw new Error("Unauthorized");
  }


  if (data?.error === "insufficient_credits") {
    alert(
      `Ø§Ø¹ØªØ¨Ø§Ø± Ú©Ø§ÙÛŒ Ù†ÛŒØ³Øª.\n` +
      `Ù…ÙˆØ¬ÙˆØ¯ÛŒ: ${data.credits}\n` +
      `Ù†ÛŒØ§Ø²: ${data.needed}`
    );
    return null;
  }

  if (data?.persistence_failed) {
    showToast("âš ï¸ ØªØµÙˆÛŒØ± Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯. Ø§Ø¹ØªØ¨Ø§Ø±ÛŒ Ø§Ø² Ø´Ù…Ø§ Ú©Ø³Ø± Ù†Ø´Ø¯.");
  }

  return data.image_base64;

  

}

function enterLoadingState() {
  previewBtn.disabled = true;
  previewBtn.textContent = "â³ Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯...";
  if (baseImg2) baseImg2.style.opacity = "0.4";
}

function exitLoadingState() {
  previewBtn.disabled = false;
  previewBtn.textContent = "âœ¨ Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´";
  if (baseImg2) baseImg2.style.opacity = "1";
}



/* ============================== Event Bindings ============================ */

// Hamburger + outside close
hambtn.addEventListener('click', handleHamburgerClick);
document.addEventListener('click', handleDocumentClick);

// Stage navigation
prevStep.addEventListener('click', handlePrevStepClick);
nextBtn.addEventListener('click', handleNextBtnClick);

// Add fabric
addBtn.addEventListener('click', handleAddBtnClick);

// Stage 1 (Upload)
sofaFile.addEventListener('change', handleSofaFileChange);
sofaCam .addEventListener('change', handleSofaCamChange);
toFabricsBtn.addEventListener('click', handleToFabricsClick);

// Stage 2 (Fabrics)
fabFile.addEventListener('change', handleFabFileChange);
fabCam .addEventListener('change', handleFabCamChange);
qToggle.addEventListener('click', handleQToggleClick);
schem  .addEventListener('click', handleSchemClick);

// Generate (Preview)
previewBtn.addEventListener('click', handlePreviewClick);

//tagging related
document.getElementById("tagFrame")?.addEventListener("click", handleTagFrameClick);
document.getElementById("undoBtn")?.addEventListener("click", handleUndoTag);
document.getElementById("clearBtn")?.addEventListener("click", handleClearTags);


// Remove fabric (IIFE in original â†’ direct binding here)
(function bindRemoveFabric(){
  const btn=document.getElementById('removeFabBtn');
  if(!btn) return;
  btn.addEventListener('click', handleRemoveFabricClick);
})();

/* ================================== Init ================================= */

// Ensure we start with an empty fabric slot if needed
(function init(){
  if(fabrics.length===0){
    fabrics.push({ id: 0, url: "", file: undefined, tags: [] });
    idx=0;
  }
  // Do not call updateUI() here to avoid any visual flicker before user input.
})();

updateLoginButton();

refreshCredits();

</script>

<div id="toast" role="status" aria-live="polite"></div>

<!-- ========================= -->
<!-- "LOGIN MODAL" + "BUY CREDITS MODAL" + "HISTORY MODAL" + "CREATION PREVIEW MODAL" (HIDDEN INIT) -->
<!-- ========================= -->
<div id="loginModal" 
     style="position:fixed; inset:0; background:rgba(0,0,0,0.6); 
            display:none; align-items:center; justify-content:center; z-index:9999;">
  
  <div style="background:#0f162b; padding:20px; border-radius:12px; width:85%; max-width:340px; color:#e5e7eb;">
    <h3 style="margin-top:0;">ÙˆØ±ÙˆØ¯ / Ø«Ø¨Øª Ù†Ø§Ù…</h3>

    <label>Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„:</label>
    <input id="loginIdentifier" style="width:100%; padding:8px; margin:8px 0; border-radius:8px;">
    
    <button id="sendCodeBtn" class="btn primary" style="width:100%; margin-bottom:10px;">Ø§Ø±Ø³Ø§Ù„ Ú©Ø¯</button>

    <label>Ú©Ø¯ Ú†Ù‡Ø§Ø± Ø±Ù‚Ù…ÛŒ:</label>
    <input id="loginCode" maxlength="4" style="width:100%; padding:8px; margin:8px 0; border-radius:8px;">

    <button id="verifyCodeBtn" class="btn" style="width:100%;">ØªØ§ÛŒÛŒØ¯</button>

    <button id="closeLoginModal" class="btn" style="margin-top:10px; width:100%;">Ø¨Ø³ØªÙ†</button>
  </div>
</div>

<div id="buyCreditsModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.55); z-index:10000; align-items:center; justify-content:center;">
  <div style="width:min(420px,92vw); background:#0f1629; border:1px solid #3a4367; border-radius:12px; padding:14px;">
    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px;">
      <div style="font-weight:700;">Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±</div>
      <button class="btn" id="buyCreditsCloseBtn" style="padding:6px 10px;">âœ•</button>
    </div>

    <div style="margin-top:10px; font-size:13px; color:#cbd5e1;">
      (ÙØ¹Ù„Ø§Ù‹ Ø¨Ø¯ÙˆÙ† Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª ÙˆØ§Ù‚Ø¹ÛŒ) ÛŒÚ© Ø¨Ø³ØªÙ‡ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.
    </div>

    <div style="margin-top:12px; display:flex; flex-direction:column; gap:8px;">
      <button class="btn" data-pack="starter" style="width:100%;">Ø¨Ø³ØªÙ‡ Starter (Ù…Ø«Ù„Ø§Ù‹ 20 Ø§Ø¹ØªØ¨Ø§Ø±)</button>
      <button class="btn" data-pack="plus" style="width:100%;">Ø¨Ø³ØªÙ‡ Plus (Ù…Ø«Ù„Ø§Ù‹ 50 Ø§Ø¹ØªØ¨Ø§Ø±)</button>
      <button class="btn" data-pack="pro" style="width:100%;">Ø¨Ø³ØªÙ‡ Pro (Ù…Ø«Ù„Ø§Ù‹ 120 Ø§Ø¹ØªØ¨Ø§Ø±)</button>
    </div>
  </div>
</div>

<div id="historyModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); z-index:10000; overflow:auto;">
  <div style="max-width:900px; margin:40px auto; background:#0f1629; border-radius:12px; padding:16px;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:700;">ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªÙˆÙ„ÛŒØ¯Ù‡Ø§</div>
      <button class="btn" id="historyCloseBtn">âœ•</button>
    </div>

    <div id="historyGrid"
         style="margin-top:16px; display:grid; grid-template-columns:repeat(auto-fill, minmax(160px,1fr)); gap:12px;">
    </div>

    <div style="margin-top:16px; text-align:center;">
      <button class="btn" id="historyLoadMoreBtn">Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¨ÛŒØ´ØªØ±</button>
    </div>
  </div>
</div>

<div id="creationPreviewModal"
     style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.7); z-index:10001; overflow:auto;">
  <div style="max-width:900px; margin:40px auto; background:#0f1629; border-radius:12px; padding:16px;">
    <div style="display:flex; justify-content:space-between; align-items:center;">
      <div style="font-weight:700;">Ù¾ÛŒØ´â€ŒÙ†Ù…Ø§ÛŒØ´ ØªÙˆÙ„ÛŒØ¯</div>
      <button class="btn" id="creationPreviewCloseBtn">âœ•</button>
    </div>

    <img id="creationPreviewImage"
         style="width:100%; margin-top:12px; border-radius:10px; display:block;">

    <div id="creationPreviewMeta"
         style="margin-top:12px; font-size:13px; color:#cbd5e1;"></div>

    <div id="creationPreviewFabrics"
         style="margin-top:12px; display:flex; gap:8px; flex-wrap:wrap;"></div>

    <div style="margin-top:16px; display:flex; justify-content:flex-end; gap:10px;">
      <button class="btn" id="reuseCreationBtn">â™»ï¸ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…Ø¬Ø¯Ø¯</button>
    </div>
  </div>
</div>



<script>
  
// ============================
// SIMPLE LOGIN HANDLING
// ============================
const loginModal = document.getElementById("loginModal");
const loginBtn = document.getElementById("loginBtn");
const closeLoginModal = document.getElementById("closeLoginModal");
const sendCodeBtn = document.getElementById("sendCodeBtn");
const verifyCodeBtn = document.getElementById("verifyCodeBtn");

const userMenu = document.getElementById("userMenu");
const logoutBtn = document.getElementById("logoutBtn");

const buyCreditsBtn = document.getElementById("buyCreditsBtn");
const buyCreditsModal = document.getElementById("buyCreditsModal");
const buyCreditsCloseBtn = document.getElementById("buyCreditsCloseBtn");

const creationPreviewModal = document.getElementById("creationPreviewModal");
const creationPreviewCloseBtn = document.getElementById("creationPreviewCloseBtn");
const creationPreviewImage = document.getElementById("creationPreviewImage");
const creationPreviewMeta = document.getElementById("creationPreviewMeta");
const creationPreviewFabrics = document.getElementById("creationPreviewFabrics");
const reuseCreationBtn = document.getElementById("reuseCreationBtn");

let lastPreviewedCreation = null;



// Wire buttons & modal behavior (history)
const historyBtn = document.getElementById("historyBtn");
const historyModal = document.getElementById("historyModal");
const historyCloseBtn = document.getElementById("historyCloseBtn");
const historyLoadMoreBtn = document.getElementById("historyLoadMoreBtn");

historyBtn.onclick = () => {
  historyModal.style.display = "block";
  loadHistory(true);
};

historyCloseBtn.onclick = () => {
  historyModal.style.display = "none";
};

historyLoadMoreBtn.onclick = () => {
  loadHistory(false);
};

// Click outside to close
historyModal.addEventListener("click", (e) => {
  if (e.target === historyModal) historyModal.style.display = "none";
});

document.addEventListener("click", (e) => {
  // --- 1) History thumbnail click ---
  const thumb = e.target.closest(".history-thumb");
  if (thumb) {
    openCreationPreview(thumb.dataset.creationId);
    return; // IMPORTANT: stop here so menu logic does not interfere
  }

  // --- 2) Close user menu when clicking outside ---
  if (
    userMenu &&
    !userMenu.contains(e.target) &&
    e.target !== loginBtn
  ) {
    userMenu.style.display = "none";
  }
});









async function openCreationPreview(creationId) {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) return;

  let data;
  try {
    ({ data } = await fetchWithAuth(`/api/creation/${creationId}`));
  } catch {
    return;
  }


  lastPreviewedCreation = data;

  creationPreviewImage.src = data.output_image_url;

  creationPreviewMeta.textContent =
    `Ù†ÙˆØ¹: ${data.mode} | Ú©ÛŒÙÛŒØª: ${data.quality} | ØªØ§Ø±ÛŒØ®: ` +
    new Date(data.created_at).toLocaleDateString("fa-IR");

  creationPreviewFabrics.innerHTML = "";
  for (const f of data.fabrics) {
    const img = document.createElement("img");
    img.src = f.image_url;
    img.style.width = "80px";
    img.style.borderRadius = "6px";
    img.title = f.role;
    creationPreviewFabrics.appendChild(img);
  }

  creationPreviewModal.style.display = "block";
}

creationPreviewCloseBtn.onclick = () => {
  creationPreviewModal.style.display = "none";
};

creationPreviewModal.addEventListener("click", (e) => {
  if (e.target === creationPreviewModal) {
    creationPreviewModal.style.display = "none";
  }
});

reuseCreationBtn.onclick = () => {
  // ALWAYS close history when reusing a creation
  if (historyModal) {
    historyModal.style.display = "none";
  }

  if (!lastPreviewedCreation) return;

  const c = lastPreviewedCreation;

  // Always restore quality toggle locally (safe)
  generationQuality = (c.quality === "standard") ? "standard" : "high";
  if (qToggle) {
    [...qToggle.children].forEach(btn => {
      btn.classList.toggle("active", btn.dataset.q === generationQuality);
    });
  }

  // IMPORTANT: define what THIS page is
  const THIS_PAGE_MODE = "pillows";

  // If creation belongs to another mode, jump to the correct page and restore there
  if (c.mode && c.mode !== THIS_PAGE_MODE) {
    localStorage.setItem("pishnama_restore_creation_id", String(c.id));
    localStorage.setItem("pishnama_restore_target_mode", c.mode);

    // Close modal before navigation
    creationPreviewModal.style.display = "none";

    // Navigate
    if (c.mode === "sofa") {
      window.location.href = "sofa";
    } else if (c.mode === "pillows") {
      window.location.href = "pillows";
    } else {
      // Unknown future mode (carpet/curtain/...) â€” donâ€™t crash
      alert("Ø§ÛŒÙ† Ù†ÙˆØ¹ ØªÙˆÙ„ÛŒØ¯ Ù‡Ù†ÙˆØ² Ø¯Ø± Ø§ÛŒÙ† ØµÙØ­Ù‡ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯.");
    }
    return;
  }

  
  // Same-mode restore (this page = pillows)  
  restorePillowsFromCreation(c);
  creationPreviewModal.style.display = "none";

};


async function fetchUrlAsFile(url, filename) {
  const res = await fetch(url);
  if (!res.ok) throw new Error("Failed to fetch file: " + url);
  const blob = await res.blob();
  return new File([blob], filename, { type: blob.type || "image/jpeg" });
}

async function restorePillowsFromCreation(c) {
  // HARD RESET before restore
  fabrics = [];
  idx = 0;
  modeSelection = "single";
  pillowsChosen = false;
  pillowsBaseFile = null;

  

  // 1) Restore base image preview + file
  
  let restoreBaseUrl = null;

  // Decide restore source based on mode
  if (c.mode_selection === "tagged") {
    if (!c.base_image_raw_url) {
      alert("Ø§ÛŒÙ† ØªÙˆÙ„ÛŒØ¯ Ù‚Ø§Ø¨Ù„ÛŒØª Ø¨Ø§Ø²Ú¯Ø±Ø¯Ø§Ù†ÛŒ Ù†Ø¯Ø§Ø±Ø¯ (ØªØµÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡Ù” Ø§ØµÙ„ÛŒ Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª).");
      return;
    }
    restoreBaseUrl = c.base_image_raw_url;
  } else {
    if (!c.base_image_url) {
      alert("Ø§ÛŒÙ† ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ù¾Ø§ÛŒÙ‡ Ù†Ø¯Ø§Ø±Ø¯.");
      return;
    }
    restoreBaseUrl = c.base_image_url;
  }

  // Restore base image file
  const baseFile = await fetchUrlAsFile(restoreBaseUrl, "base.jpg");

  pillowsBaseFile = baseFile;
  pillowsChosen = true;

  loadImage(sofaThumb, baseFile);
  loadImage(baseImg2, baseFile);
  // 


  // 2) Restore mode selection (single/random) from c.mode_selection
  if (typeof c.mode_selection === "string") {
    modeSelection = c.mode_selection;  // your existing state var
    // update any UI highlight for mode buttons here if you have them
  }

  // 3) Restore fabrics
  fabrics = [];
  for (let i = 0; i < c.fabrics.length; i++) {
    const f = c.fabrics[i];
    const file = await fetchUrlAsFile(f.image_url, `fabric_${i + 1}.jpg`);

    fabrics.push({
      id: i,                              // âœ… numeric, UI-consistent
      url: URL.createObjectURL(file),
      file,
      tags: []                            // âœ… required for upcoming tagging mode
    });

  }

  idx = 0;

  // ğŸ”´ FIX: re-enter tagged-mode initialization if needed
  if (modeSelection === "tagged") {
    if (tagBaseImg && pillowsBaseFile) {
      const u = URL.createObjectURL(pillowsBaseFile);
      tagBaseImg.src = u;
      tagBaseImg.onload = () => { try { URL.revokeObjectURL(u); } catch(e){} };
    }
  }

  gotoFabrics();   // ğŸ”§ REQUIRED: advance to stage 2 after restore

}





function isValidEmail(str) {
    return /\S+@\S+\.\S+/.test(str);
}

function isValidPhone(str) {
    return /^09\d{9}$/.test(str);
}

function normalizePhone(str) {
    // input: 09123456789 â†’ output: +989123456789
    if (isValidPhone(str)) {
        return "+98" + str.slice(1);
    }
    return str;
}


// Toggle user menu when clicking the identifier (loginBtn)
loginBtn.onclick = () => {
    const token = localStorage.getItem("pishnama_user_token");
    if (token) {
        // User is logged in â†’ show/hide menu
        userMenu.style.display = 
            userMenu.style.display === "block" ? "none" : "block";
    } else {
        // User not logged in â†’ open login modal
        loginModal.style.display = "flex";
    }
};

logoutBtn.onclick = () => {
    // Clear stored credentials
    localStorage.removeItem("pishnama_user_token");
    localStorage.removeItem("pishnama_user_identifier");

    // Update UI
    updateLoginButton();

    // Hide menu
    userMenu.style.display = "none";

    // Optional user feedback
    showToast("Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø®Ø§Ø±Ø¬ Ø´Ø¯ÛŒØ¯.");

    document.getElementById("historyGrid").innerHTML = "";
    historyPage = 1;

    lastPreviewedCreation = null;
    creationPreviewModal.style.display = "none";

};


closeLoginModal.onclick = () => loginModal.style.display = "none";

function openBuyCreditsModal() {
  const token = localStorage.getItem("pishnama_user_token");
  if (!token) {
    alert("Ø¨Ø±Ø§ÛŒ Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø±ØŒ Ù„Ø·ÙØ§Ù‹ ÙˆØ§Ø±Ø¯ Ø´ÙˆÛŒØ¯.");
    loginModal.style.display = "flex";
    return;
  }
  buyCreditsModal.style.display = "flex";
}

function closeBuyCreditsModal() {
  buyCreditsModal.style.display = "none";
}

async function buyCredits(packageId, confirmBurn = false) {
  let data;
  try {
    ({ data } = await fetchWithAuth("/api/buy-credits", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        package: packageId,
        confirm_burn: confirmBurn
      })
    }));
  } catch {
    return; // login_required already handled
  }

  if (data?.requires_confirmation) {
    const ok = confirm(
      data?.message ||
      "ØªØ¹Ø¯Ø§Ø¯ÛŒ Ø§Ø² Ø§Ø¹ØªØ¨Ø§Ø±Ù‡Ø§ÛŒ ÙØ¹Ù„ÛŒ Ø´Ù…Ø§ Ù…ÛŒâ€ŒØ³ÙˆØ²Ø¯. Ø§Ø¯Ø§Ù…Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒØ¯ØŸ"
    );
    if (!ok) return;
    return buyCredits(packageId, true);
  }

  if (data?.error) {
    alert(data.error);
    return;
  }

  alert("âœ… Ø®Ø±ÛŒØ¯ Ø§Ø¹ØªØ¨Ø§Ø± Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.");
  closeBuyCreditsModal();
  refreshCredits();
}


buyCreditsBtn?.addEventListener("click", openBuyCreditsModal);
buyCreditsCloseBtn?.addEventListener("click", closeBuyCreditsModal);

// Click outside card closes
buyCreditsModal?.addEventListener("click", (e) => {
  if (e.target === buyCreditsModal) closeBuyCreditsModal();
});

// Package buttons
buyCreditsModal?.querySelectorAll("[data-pack]")?.forEach(btn => {
  btn.addEventListener("click", () => buyCredits(btn.dataset.pack));
});



// Send code
sendCodeBtn.onclick = async () => {
  let identifier = document.getElementById("loginIdentifier").value.trim();
  if (!identifier) return alert("Ù„Ø·ÙØ§Ù‹ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯.");

  if (!isValidEmail(identifier) && !isValidPhone(identifier)) {
      return alert("Ù„Ø·ÙØ§ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø±Ø§ Ø§ØµÙ„Ø§Ø­ ÙØ±Ù…Ø§ÛŒÛŒØ¯");
  }

  // Normalize phone to +98 format for backend
  identifier = normalizePhone(identifier);

  await fetch("/api/request-code", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({identifier})
  });

  alert("Ú©Ø¯ Ø¨Ø±Ø§ÛŒ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.");

};


// Verify
verifyCodeBtn.onclick = async () => {
  
  let identifier = document.getElementById("loginIdentifier").value.trim();
  if (!isValidEmail(identifier) && !isValidPhone(identifier)) {
      return alert("Ù„Ø·ÙØ§ Ø§ÛŒÙ…ÛŒÙ„ ÛŒØ§ Ø´Ù…Ø§Ø±Ù‡ Ù…ÙˆØ¨Ø§ÛŒÙ„ Ø±Ø§ Ø§ØµÙ„Ø§Ø­ ÙØ±Ù…Ø§ÛŒÛŒØ¯");
  }
  // normalize before sending to backend
  identifier = normalizePhone(identifier);


  const code = document.getElementById("loginCode").value.trim();

  const res = await fetch("/api/verify-code", {
    method: "POST",
    headers: {"Content-Type": "application/json"},
    body: JSON.stringify({identifier, code})
  });

  const data = await res.json();
  if (!data.token) return alert("Ú©Ø¯ Ø§Ø´ØªØ¨Ø§Ù‡ Ø§Ø³Øª.");

  // Save token + identifier
  localStorage.setItem("pishnama_user_token", data.token);
  localStorage.setItem("pishnama_user_identifier", identifier);

  // Close modal
  alert("ÙˆØ±ÙˆØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯!");
  loginModal.style.display = "none";

  // Update UI
  updateLoginButton();

  refreshCredits();

};

window.addEventListener("storage", (e) => {
    if (e.key === "pishnama_user_token") {
        updateLoginButton();
        userMenu.style.display = "none";  // closes the user dropdown menu in other tabs after logout
        loginModal.style.display = "none";   // closes login panel in other tabs
    }

    if (localStorage.getItem("pishnama_user_token")) {
      refreshCredits();            // login in another tab
    } else {
      const ci = document.getElementById("credit-info");
      if (ci) { ci.textContent = ""; ci.style.display = "none"; }
    }

    // =========================
    // Theme sync across tabs
    // =========================
    if (e.key === "pishnama_theme") {
        const theme = e.newValue || "dark";
        document.documentElement.setAttribute("data-theme", theme);

        const btn = document.getElementById("themeToggleBtn");
        if (btn) {
            btn.textContent = theme === "dark"
              ? "â˜€ï¸ Ø­Ø§Ù„Øª Ø±ÙˆØ´Ù†"
              : "ğŸŒ™ Ø­Ø§Ù„Øª ØªÛŒØ±Ù‡";
        }
    }


});

(async function autoRestoreIfRequested() {
  const token = localStorage.getItem("pishnama_user_token");
  const id = localStorage.getItem("pishnama_restore_creation_id");
  const targetMode = localStorage.getItem("pishnama_restore_target_mode");

  if (!token || !id) return;

  // This pageâ€™s mode (same constant you used above)
  const THIS_PAGE_MODE = "pillows";
  if (targetMode && targetMode !== THIS_PAGE_MODE) return;

  try {
    // Clear first to prevent loops if something errors
    localStorage.removeItem("pishnama_restore_creation_id");
    localStorage.removeItem("pishnama_restore_target_mode");

    // Fetch full creation and restore
    let c;
    try {
      ({ data: c } = await fetchWithAuth(`/api/creation/${id}`, {
        auth: { silent: true }
      }));
    } catch {
      return;
    }


    // Apply quality UI
    generationQuality = (c.quality === "standard") ? "standard" : "high";
    if (qToggle) {
      [...qToggle.children].forEach(btn => {
        btn.classList.toggle("active", btn.dataset.q === generationQuality);
      });
    }

    if (c.mode === "pillows") {
      await restorePillowsFromCreation(c);
    }
  } catch (e) {
    console.error("Auto-restore failed:", e);
  }
})();


</script>

<script>
/* =========================
   Theme toggle with OS detect + icon swap
========================= */
(function initThemeToggle(){
  const KEY = "pishnama_theme";
  const btn = document.getElementById("themeToggleBtn");

  function apply(theme){
    document.documentElement.setAttribute("data-theme", theme);
    if (btn) {
      btn.textContent = theme === "dark"
        ? "â˜€ï¸ Ø­Ø§Ù„Øª Ø±ÙˆØ´Ù†"
        : "ğŸŒ™ Ø­Ø§Ù„Øª ØªÛŒØ±Ù‡";
    }
  }

  function detectOSTheme(){
    return window.matchMedia &&
           window.matchMedia("(prefers-color-scheme: dark)").matches
           ? "dark"
           : "light";
  }

  // Priority:
  // 1) User choice
  // 2) OS preference
  const saved = localStorage.getItem(KEY);
  const initial = saved || detectOSTheme();
  apply(initial);

  if (btn) {
    btn.addEventListener("click", () => {
      const current =
        document.documentElement.getAttribute("data-theme") || initial;
      const next = current === "dark" ? "light" : "dark";
      localStorage.setItem(KEY, next);
      apply(next);
    });
  }
})();
</script>

</body>
</html>
